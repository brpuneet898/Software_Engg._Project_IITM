we looked at creational design patterns so we saw that creational patterns they provide object creation mechanisms right they help us create objects in an efficient manner in this video we look at structural patterns so structural patterns help us assemble objects and classes into larger structures and help us to keep these structures flexible and efficient so we are going to look at some structural design patterns in this video the first structural design pattern we are going to look at is the facade design pattern so let's say you have to create several objects and perform several steps so let's say you are to initialize many objects and for a particular task you need to execute methods in the correct order give the right parameters Etc right so or you need to have use existing complicated Library functions right and the clients or others who are going to reuse your code they will face an issue all right they will have to know details about which all are the different objects to be created what are the necessary Library functions Etc right and this makes it difficult for the client to use your code so let's take an example from the seller portal itself let's say after a buyer places an order the system should do the following task the system should create an order order the system should notify the appropriate seller prepare the packaging and send the item out for delivery right so here we see that there are several steps which need to be performed so let's look at how we can implement this in our code right so we have different classes one for order which places the order then a class called seller which has a seller notification a package class which packages the order and the delivery class which delivers your right and in my code I have to first create an order right provide the product name in this function and create a seller create the seller or call the seller notification function with the appropriate seller name then create a package object and create a delivery object so there is there are several steps which I need to perform right once a buyer buys a product now let's reflect on this question can how can I make this code better for the client right the client need not or should necessarily not need to know the exact steps which are required right so just reflect on this and see if we can find a better solution to this problem so this problem can be solved using the facade design pattern so facade design pattern it provides a simple interface to a library or a complex set of classes so for example let's say there are several functions and classes which need to be called right for a particular operation so in the facade design pattern you create a class which has a method which calls all the respective or required functions and places them in a single method so in this case do something calls all the appropriate methods in each of the individual classes and now clients do not have to remember each of the individual function calls but we'll just have to call do something with the necessary parameters so let's see how we can make changes into our existing code to implement the facade design pattern so the code on the right implements the facade design pattern so we can see that the individual classes and the methods remain the same right so order seller package delivery they remain the same and what we will do is create a new class called let's say delivery facade and it will have a method which will take all the function calls and object creation mechanisms and place it into the single function called deliver right and now the client need not call all of these individual functions nor do they have to create each of these individual objects all that I will do is create an object of the delivery facade type and call the deliver function with the appropriate parameters so in this way we see that the client did not remember the different objects to be called nor does it need to remember now the exact step of which all functions need to be called so what are the pros and cons of using the facade design pattern so one advantage is as we saw that it helps us isolate the complexity of the code or the different libraries that we have and expose clients to just a single method or function the disadvantage of using the facade design pattern is that the facade is tightly coupled to other objects and because of this maintenance becomes more difficult so for example in this case we see that the delivery facade is coupled to the order the seller the package and the delivery classes right and if any change happens in any of these objects or these functions then we need to make appropriate changes in the delivery facade class as well now let's look at the next design pattern which is the adapter design pattern so let's look at the problem let's take the example of the Amazon Seller portal itself and let's say some products have cost in dollars or euros and hence conversion to rupees is needed right and now let's say we have a product class and we have a library or a class called as conversion converter so conversion converter is uh an existing library for which we do not have controller right so this product class cannot directly access the conversion converter class or it has an incompatible interface to that of the product class right so let's say conversion calculator is an interface which is not compatible with products so product cannot directly access the conversion calculator due to various reasons right so in such cases the adapter design pattern comes in handy right so what is the adapter design pattern so between so let's say the client wants to call method B right and the client cannot directly call method B so what we can do is create an adapter class right and what the adapter class does is it provides a wrapper or it provides a link between the client and the adapting so what the client will do is call the adapters method and the adapter in turn will call the adaptees method right and these methods might be incompatible to each other but that issue of incompatibility is taken care of by the adapter right so the adapter wraps one of the objects to hide the complexity of what is happening behind the scenes right and the client need not be aware of you know what are the complexities involved the adapter takes care of that now let's look at how we can implement this in our code so we have a class called conversion calculator which does the conversions to dollars from dollars to Rupee and from let's say Euros to Rupee right and we have another class called Product right which has the attributes of product and for this example let us assume that conversion calculator and product are incompatible they cannot talk to each other right so what we will do is we will create an adapter called let's say cost calculator adapter which acts as a bridge or a wrapper between the product and the conversion calculator right so cost calculator adapter takes a product p and creates an object of the conversion calculator and passes the product cost to the appropriate function in the conversion calculator and if we look at the product class we see that the product class it creates an adapter object and it calls appropriate adapter function so the product need not know any of the details regarding the conversion calculator class right and in this case in the main function we create a product and we add a product and when we add call this add product function the add product function creates an adapter object and the adapter object gets the cost in rupees by calling the conversion calculate so in this case the cost was 300 and when we run the code we get the cost in rupees so let's look at some of the pros and cons of using the adapter design pattern so one advantage is that we are following the single responsibility principle right so in our case we were we separated the code to convert from dollars to rupees or Euros to rupees from the actual business logic of the product class which is to add products edit delete products right in that way we are following the single responsibility principle the other Advantage is that if we want to add new types of adapters let's say for other currencies then this can be done easily and this follows the open close principle where we say that a class should be opened for extension so we can extend the functionality of these classes by adding new types of adapters the disadvantage is that the complexity of code can increase so let's say we are adding an adapter so we have to add a new class and add appropriate methods and if we were able to make changes in the product class or maybe get access to the conversion calculator then we need not create a separate class for this purpose so in that way the overall code complexity can also increase