we looked at different levels of testing so we start with unit testing where individual functions or units of the program are tested and then these units are incrementally integrated and then the fully integrated system is tested and finally we give it to the customers right so these are the different levels of testing and in this video we are going to focus on unit testing so before we look at the different aspects of unit testing here's a Reflections part so why do we actually need to do unit testing right it's if you see it's a very painstaking process of individually testing each module right and then we have to integrate and test all of these modules once again so why not just integrate and test once and for all right it can save time and effort of the developers also so why do you think unit testing is important so please pause the video here and write down your responses before proceeding okay so why do unit testing right so one reason is that as we saw earlier modules are not developed by a single developer right there they are developed by different people who are building other modules also right so while I am developing a module right the other modules might not be ready as at all right and hence it is not possible to do system or integration testing at the start itself right and another important reason why we should do unit testing is that it makes debugging easier so let's say a failure or error is detected right and when an integrated set of modules are tested so how will we know which module as the error right so on the other hand if we tested each unit individually or each module individually we can resolve the bugs and failures in each module and hence unit testing makes debugging easier so these are some reasons why we should do unit testing always so now let's look at some more details of what unit testing entails right so when should we do unit testing unit testing should be done actually during the coding of the module right and not in the testing phase right it's not that we develop the module and then we start testing right as we code the modular as we develop a module we should be doing the unit testing of that as well and who should be doing this so the person who writes the code for the module ideally that person is the one who should be doing the unit testing as well and what is involved when one does unit testing so as we saw in the previous video we need to design test cases right so unit test cases have to be designed and not only that there is something known as a testing environment for the unit under test right so this environment also has to be designed so what is this testing environment so let's say this is we want to test a module right so this is the module to be tested you know but remember that this module itself might be calling other functions let's say function 1 2 and 3. and as of now right now these functions are not available to me as a developer of this module right it might be under development or it might be in the process of development and this is written Maybe by someone else and not me so right now I don't have access to function one two and three for example and not only that there are some non-local data or global data which this module has to access right so when I develop a testing environment I somehow need access to the known non-local data as well as these different functions so in the testing environment there are two important Concepts which we need to consider and one is known as a stub and the other is known as a driver so what is a stub so a stub is nothing but a dummy procedure right that has the same signature or the same input output parameters as the function called by the unit under which we want to test but it has a very simplified Behavior it's highly simplified so in the previous screen we saw functions F1 F2 F3 right and we know the signatures of these functions how many parameters what is the return type and we create dummy procedures F1 F2 F3 right and a simplified behavior of each of these functions and these functions are known as stubs and the driver module that contains the non-local data structures which will be accessed by the module under test so we will be looking at these Concepts in detail in this video now in Python there are several unit testing tools and the most popular ones are unit test and Pie test so unit test is a built-in standard library for testing python code and Pie test is another popular testing tool which is used and it helps to minimize boilerplate code so in this video we will be looking at Pi test so let's look at a simple example of how we can use Pi test so in this code is the seller portal code right which simulates some parts of the seller portal so we have a product class right wherein you can add a product and view product details then you have an inventory which has a map of products and number of items in that product so it takes a product ID and for each product ID it has number of items right and you can add items to the inventory where the number of items are updated or you can delete items from the inventory right and here we are doing basic checks like let's say if the number of items in the inventory is less than the number of items to be deleted it will raise an exception it will raise an exception or it will reduce that many number of items from the invent right and let's say this inventory class is being implemented by some other developers so they are still in the process of writing the function so get total items what it ideally should do is calculate the total number of products in the inventory right and it's not implemented yet and my seller portal is you know importing the product and the seller inventory classes and creating objects right so P1 is a product object and you're adding objects and S1 underscore inventory is an inventory object right so with this context now let's see how we can use a testing framework like pie test so to install Pi test what you have to do is just type install Pi test and in my case it's already there so what I can do is just simply run Pi test or you know call the module Pi test right and here you can see that the message which comes as no test run right so for Pi test to run or what pythons does is it looks for tests right in the given fold so what I can do is I can create let's say uh file write a python file called test underscore seller portal Dot py right and it's necessary that the file name should have test underscore at the start right and let's say I create a simple function right so let's take an example of let's say a function which just Returns the double of a number right and let's say I want to test this so here again for each test case right I add or I prefix it with test underscore so this tells Pi test that this is actually a test case whereas this is a normal function right and now how I actually test is to use the assert keyword so I can say let's say assert double of 10 should be equal to 20. right so now this test underscore seller portal.py contains my test Suite which contains the set of test cases right and right now I just have one right and each test case should be prefixed with this test underscore term right so now in this now when I run by test right it says that one test is passed right which is this now for example if I remove the test underscore right and if I save it and if I try running it it says that notice right right similarly if I rename this to some other value let's say like ABC right done Pi test again you know pyta says that no test tests were run so it's important that you always add the prefix test underscore to your test Suite as well as your test cases right each method where you're checking for a particular test case all right so now let's try to see how we can test individual functionalities of the product and the inventory classes right so what we will do is first of all I will import from product let me import the product class and from inventory let me import the seller admit right and let's say I'm testing maybe I want to check if this add items to inventory method is working correctly right so what I will do is I will create a test case or add new item to invent so it's a standard practice to specify you know what the test case does in the method itself right that's a good practice right okay so what I'll have to do is first I have to first I would have to create a inventory object right so let's say I call inventory equal to seller inventory and let's say S1 is the seller right and then I have this function called add items to inventory which takes the product ID and number of items so I have inventory dot add items to inventory which takes let's say product P1 and adds 10 units of P1 to the invent right and what it actually does is it updates the seller inventory map right so a seller inventory map is nothing but a dictionary which takes the product ID as a key and the number of items as the value so to check if this function is working correctly I would just have to let's say assert so I have my inventory so inventory has the seller inventory map and if my key P1 right corresponding value if it is 10 right that means you know this function is working correctly so if I run Pi test now so I see that one test is passed now another another functionality which I want to test might be I let's say I have added something previously and I'm adding things again right so what I I want to test if if something which has been added previously sleep right does it update the inventory right so again let's say I create an inventory object and then again let's say I add 10 more entries right so now I can assert whether my inventories seller inventory map for P1 it should ideally have 20 items right and I can test this here it's saying two test cases have passed right so here for example instead of you know I would have you know forgotten the plus symbol for example right and now if I try running the test so this means that each time I add something it does not update it but it replaces with the current number of items so now if I run the test case yes so here you see that it gives an assertion error right deserts that 10 so what this returns is actually 10 right and that is not equal to 20. right so the test had previously added item to inventory is failing right so so I will replace or I'll correct the error and now if I run it all my test cases have passed now similarly I can add other test cases right so now there is another method known as delete items right so let's say I want to check whether this method is working correctly so let's say I want to test if now let's say when I'm deleting items I want to check if the number of items I'm deleting is less than the total items right less than the total items from inventory right so again let's say I um if let's say I add 10 items to my inventory and let's say I'm now deleting from P1 let's say I'm deleting five right now I want to check if my inventory right for P1 it should ideally be 5. right so now when I run my test cases yes so the delete items less than is also working correctly so if you have noticed in this code there we have right now we have three test cases but you can see that you know there are some initializations which are happening multiple times right so each in each test method we are initializing inventory right there is a better way to do this initialization and that is by using what is known as fixtures right so in Python in pi test we can use what is known as a fixture by writing or by creating methods which initialize certain things for us right so let's say I have I can create a method called inventory which does this thing for me right it initializes an inventory object right and I can return this invent right and now for each of my test cases right I can call the inventory method right which is a fixture and that makes this inventory available for the test right so I need not initialize it now right and so I can do the same thing for the other test cases as well right I pass what I call the inventory function and now the inventory method is available the inventory object is available in all the test cases so now if I done right so all the three test cases are passed so using fixtures we can initialize certain things which we want to do or or create some things which are needed in all the test cases so we have in the delete items we have deleted some items which are less than the total items from the inventory right another thing which we can do is the other way around right suppose if I delete items which are more than the total items items in the inventory right so let's look at the code and let's see what's happening when my the items which I want to delete are more than the total items right so if the number of items which I want to delete are more than the current number of items then this throws an exception right and in pi test we can also test for whether these exceptions have been raised right and how we can do that is by using the phrases function and we want to check if value error has been raised right so so let me just let's say add items to the inventory let's say I add 10 items and let's say I want to now delete so I want to delete items from the inventory let's say I want to delete 20. right and in this case it should write through an exception or it should give a value error and we can test that using the resist so now if I run this I see that this also passes right however if this was let's say 5 right and it should not raise a value error because 10 is greater than 5 right so in this case this will fail right so this tells me that my program is running correctly now if we look at the inventory class right we have a function called get total items right which I said has not been implemented yet so let's say I have in my inventory I have product P1 with 10 items and P2 with 10 items or 20 items right so the total number of items should be 10 of P1 Plus 20 of P2 should be 30 right so however this this feature has not been implemented yet right and maybe the inventory module is being developed by some other developer right and for my module I am using the inventory module right to put in my application or in my module so now this causes a problem right because I want to test whether my module is correctly capturing or correctly using the inventory functions right however it has not been implemented yet right so let's see how we can work around this problem so now let's say if I want to test this functionality right which has not been implemented yet which is get total items so I want to test the total items in my inventory again I have access to the inventory object right and let's say I add 10 items here and I add 20 items of people right and now I'm I want to assert that my inventory so ideally I would want this get total items right right now the current state is 30. right now if I try running this okay it should give me an error because this function has not been implemented yet right and that's why it's giving none which is equal to 30 and this is failing right so how do we work around this problem where we want to use functionalities from other modules which are being developed by other developers but we don't have access to it yet right and this is where the concept of stub comes in right we create a mock method or a dummy method right which will mimic the functionality of that function or method right so what we'll do is we will create what is known as so I'm creating a function called mock get total items right which takes the inventory right and it calculates the total right so my inventory map has product ID and let's say the number of items right inventory has something known as a seller inventory map right which is a dictionary and I call its items and for each item I update the total right and this function should return now what I will tell this test is so my inventory functions get my sorry my inventory objects get total items should not call the inventory modules get total items but instead what you can do is mock the functionality right and we use what is known as the mock object and we say no the side effect equal to and the function which we need to call is actually this one right so what we are saying is instead of calling inventories get total items we are mocking or we are creating a stub which simulates the functionality right and we have you know simulated it here and that's what we are calling here right so now when we say you know get total items and we pass the inventory object now what we are checking is whether you know this functionality is being implemented so now if I try to run this I see that all my tests have passed so in this way we can use Pi test right to test our programs so we saw that how we can create different test cases to test each method and in each method we can use it to test different conditions right let's say we have added something to the inventory we have deleted something from the inventory and for delete there were other conditions as well we looked at how we can also check for exceptions right and we also saw how we can create mock functions right so let's say we have not or certain functionalities are not available to us we can create stubs or we can mock or mimic that functionality using this feature of Pi test