videos we looked at various testing techniques like unit testing integration testing system testing and if you've noticed in all of these testing techniques we write tests after we write the code right that's the natural way that we go about doing testing right but another strategy which is used especially in agile processes is this technique known as test driven development or tdd so in tdd we write tests first before even implementing the functionality that we want to implement right so we write tests first for the functionality and then we go about implementing that functionality and as the name suggests we drive design and development of that functionality from tests so we iteratively write tests to implement a functionality Implement that functionality then write another test and Implement that functionality sub functionality and so on so we organize all our activities around verifying small features or functionalities that we have built so let's see how test driven development works so let's say we were building a small functionality or a function or a module right so the first thing which we do is we express this requirement of feature or user story in the form of a test right we have not written any code yet we are just specifying what the test is and then we create this test and we run this test and since we have not implemented the feature of course it will fail right so we deliberately create a test and make it fail and now the next step we create the minimum code to meet the needs of this test now our goal is to somehow make this test pass right so we implement the minimum code which is required to to make this test pass and after we have done that we we run the test and see that it passes right so now for a small functionality or feature we have designed a test case initially it failed now we wrote the minimum code to make it pass and now we refactor this score right so we now now know that this code ensures that the requirement is satisfied now I try to refactor this code to make it for example more modular more elegant use the coding practices which we learned in the previous weeks right and we refactor this code so that it still passes the test right so this is the mantra for test driven development so this is known as red green refactor first we write a test and we see that it fails then we write code which will the minimum code required to pass that test that is green and then we refactor the code and make it better and this might be for one small sub functionality then to implement some other sub functionality we again iteratively follow this test so we again write a test for that next sub functionality it fails we write minimum code and then we refactor so we follow this cycle of red green refactor for each sub functionality until we have built the entire functional so now that we have seen what test driven development is let's try it out with a small example so let's try creating the is prime function which we saw earlier right so I'll create a new file called is prime right and I want to create a function called is prime is prime which takes a number as input right and let's see how we can use tdd to write this function right so now in test driven development what we do is I start by creating tests right so I write say I create a test file right and from my is prime function I import is prime all right so in tdd we start by writing test right we make test fail first and then we write the minimum code to pass that test and we refactor and we keep on doing this right reiterate so let's think of the first test case right so let's say we want to test if a number is not prime okay so if I'm under test if my number is not Prime and what I want to do is I want to assert that if I pass a non-prime value then it should be false right so whenever I pass a number which is not prime to is prime function is to this Prime function it should return false right so let's try running this test so I say by test let's and it should fail right so this is the first part which is the red now I will write code such that I'll write minimum code such that this test should pass right so now let's look at our function right so I will so the logic is I will iterate from let's say 2 to the number right and how do I know if a number is not Prime so if that number mod I right equal to zero then I return false right so in this way I have just created or I have just implemented a sub functionality or a small part of the S Prime function right which just checks whether a number is just checks for non-prime numbers right because that is the test for which I have the test I want to check so now if I again call Pi test I see that my test has passed okay great now what I can do is I will write another test to check if the number is prime right and I will write an assertion that I will call S Prime for a number let's say Prime for a prime number like 5 this should return true right but in this case we have not modified is prime to check for prime numbers right so if I run Pi test right this function right this assertion is not satisfied right it's false so this test phase now I go back to my function and I try to see when or I try to implement the logic for returning true when it is a prime number right so when is the number Prime when I iterate through all the numbers up to num right and up to num minus 1 and it is not divisible by any of those numbers right so that means I can return true in this case right so let's now when we run Pi test we see that both the test cases have passed right so in this way we have incrementally and iteratively built this is prime function right and the test cases has had has driven the development of this function right and that is the power of tdd where you can incrementally test as well as build your application or build your program right but now in this case we have not checked for let's say the number two right so if I want to create suppose the number is let's say two so assert does this function recognize whether 2 is prime okay let's run this right even for two it is working right and now I check for let's say if the number is one one so one is not a prime number should return false so let me check and here we see that this test case fail fails right so then now I go back to my code and I realize that you know I'm just checking from two onwards right so maybe at the start here I say if the number equal to 1. right I return false and now if I run my test cases again right even that has passed right the same thing for let's say 0 right if the number is zero again I want this Prime to return false it doesn't right so then again I go back to my program and let's say for zero as well it should return false oops right right so we see that all the test cases have passed right so in this way we can use tdd to build right simple as well as complex programs right where we iteratively create test cases and we follow the Mantra right we first make the test case fail then write minimum code to pass the test case and once each test case has passed then we try to refine and refactor our code to make it better so this was an example of how you can use tdd when you write programs now similarly I can add other test cases right so now there is another method known as delete items right so let's say I want to check whether this method is working correctly so let's say I want to test if now let's say when I'm deleting items I want to check if the number of items I'm deleting is less than the total items right less than the total items from inventory right so again let's say I um if let's say I add 10 items to my inventory and let's say I'm now deleting from P1 let's say I'm deleting five right now I want to check if my inventory right for P1 it should ideally be 5. okay so now when I run my test cases yes so the delete items less than is also working correct so if you have noticed in this code there we have right now we have three test cases but you can see that you know there are some initializations which are happening multiple times right so each in each test method we are initializing inventory right there is a better way to do this initialization and that is by using what is known as fixtures right so in Python in pi test we can use what is known as a fixture by writing or by creating methods which initialize certain things for us right so let's say I have uh I can create a method called inventory which does this thing for me right it initializes an inventory object right and I can return this invent right and now for each of my test cases right I can call the inventory method right which is a fixture and that makes this inventory available for the test right so I need not initialize it now right and so I can do the same thing for the other test cases as well right I pass what I call the inventory function and now the inventory method is available the inventory object is available in all the test cases so now if I run right solve the three test cases are passed so using fixtures we can initialize certain things which we want to do or or create some things which are needed in all the test cases so we have in the delete items we have deleted some items which are less than the total items from the inventory right another thing which we can do is the other way around right suppose if I delete items which are more than the total items items in the inventory right so let's look at the code and let's see what's happening when my the items which I want to delete are more than the total items right so if the number of items which I want to delete are more than the current number of items then this throws an exception right and in pi test we can also test for whether these exceptions have been raised right and how we can do that is by using the phrases function and we want to check if value error has been raised right so so let me just let's say add items to the inventory let's say I add 10 items and let's say I want to now delete so I want to delete items from the inventory let's say I want to delete 20. right and in this case it should write through an exception or it should give a value error and we can test that using the raises method so now if I run this I see that this also passes right however if this was let's say 5 right and it should not raise a value error because 10 is greater than 5 right so in this case this will fail right so this tells me that my program is running correctly