patterns so what are design patterns so design design patterns are nothing but descriptions of how objects and classes should communicate with each other to solve a general design problem in a particular context right so as we saw earlier design patterns have evolved over many years and several experienced Developers realize that these patterns appear again and again in code and hence these patterns have been generalized and these descriptions are known as design patterns foreign so what are elements of a design pattern so first we need to identify the problem for which a particular design pattern can be applied to so we need to know when to apply the design pattern and in what context right so that is the first thing we need to know then we apply the design pattern that forms part of our solution and this solution it describes the elements that make up the design so what are the relationships between classes between objects how do they collaborate with each other so these are different aspects of the solution and this solution it serves as a template right which can be applied in different situations and finally when we apply a design pattern it has certain consequences right we need to understand what the trade-offs are what the costs are what the benefits are and when whether we actually need to apply the design pattern or not in a particular context now that we know what the elements of a design pattern are let's look at certain types of design patterns so there are three types of design patterns one is known as a creational design pattern it is used during the process of object creation right so whenever we want to create objects in certain situations certain design creational design patterns can be used and this will give us more flexibility as well as help us reuse existing code we will look at examples of creational design patterns another type of design pattern is known as the structural design pattern so structural design patterns it explains how we can assemble objects and classes into larger structures again with the aim of making our code more flexible and efficient and the third type of design patterns are known as behavioral design patterns these patterns ensure that there is effective communication between objects and classes as well as it ensures that the responsibility between objects are distributed properly right we will be looking at examples of each of these types of design patterns now that we have seen the different types of design patterns in this video we'll be looking at two types of creational design patterns the factory design pattern and the Builder design pattern so let's look at the factory design pattern first so let's take an example of the seller portal itself and let's say I want to implement a functionality where I need to deliver a package using a particular Courier Service so I need to deliver a package using a particular Courier Service so looking at this functionality you realize that you will need two objects or two classes one is the delivery which delivers the package right using a particular Courier Service so Courier forms another class and we see that there's an association between delivery and Courier so the delivery class has a method called deliver which takes Courier as an argument so let's see how we can implement this functionality thank you so this is a simple code right which implements this functionality so as we saw we have two classes a delivery class which has a method called deliver which takes Courier object as an argument Courier is another class which has certain parameters and certain methods right and what we what we'll do in the main method is we create a courier object right and we create a delivery object and the delivery object calls the deliver method which takes Courier as an argument right and now if we run this code yeah so it prints certain messages so delivered via National courier service within India which is part of the deliver method so now let's say you have you have been delivering couriers nationally within India now let's say certain products have become very popular and you want to deliver it internationally you want to deliver it outside India so you would require other types of Courier Services right International couriers and they function or the functionality for an international Courier might be slightly different right the delivery also has a separate process so that would mean you need to make some changes in either the delivery and The Courier classes right so let's reflect on this for a moment what changes will you make in the delivery class and The Courier class in order to extend the functionality of sending couriers internationally as well you can pause this video and think about what changes you can make before proceeding all right so what changes will you make to include the functionality of adding let's say International couriers so one way to do it might be to set The Courier type to the type of Courier right so let's say it is National then Courier type is National if it is international then Courier type is international and in the deliver method we can check the type of Courier so if the Courier type is National right then we can say no then we can apply the logic of how we can deliver it nationally otherwise else you know that would mean it's an international Courier and then we write the logic for how we can deliver something International but if you notice this is actually violating one of the solid guidelines which we saw earlier can you think of which guideline it is violating so this code is actually violating the open flows principle right so which states that an object or a class should be open for extension but it should be closed for more modification so in this case you can see that we are actually modifying this class where or whereas we should have been extending the functionality so the factory design method helps us do that in an effective manner so let's see how we can do that so recall that this was our code earlier right and I need to extend this functionality to deliver packages internationally as well so in the factory design pattern what I will do is I will replace direct object construction calls with calls to a special Factory method okay so what does this mean let's look at our example again so this was our code earlier right and now after we apply the factory design pattern what we will first do is make these delivery and Courier classes abstract right and based on the type of Courier we want to send we will create separate classes which extend The Courier class right so we'll create a class called National Courier we'll create another class called International Courier right which have which corresponds to sending something nationally and internationally and in addition we will also create classes which extend the delivery class one which corresponds to National delivery another which corresponds to international delivery and in this case we have an additional method called create Courier which returns a courier object right so the delivery plus has a Creator method which creates a or which returns an which returns a courier object and so the national delivery class will have will return a national Courier the create career method will return a national Courier object and similarly the international delivery class has a method called create Courier which returns an international Courier object right so the responsibility of creating objects has now been dedicated to these classes the national delivery and the international delivery and to a specific method known as the factory method so in this case the create Courier method is known as a factory method which actually creates The Courier objects the the appropriate Courier object based on our condition so now let's see how we can implement the factory design pattern in our code so recall that we had a class called delivery another class called Courier and we created a courier object right and we passed that to the delivery object d right so in the factory design pattern what we'll do is we will create an abstract or make this class as abstract the delivery class is abstract and we create a factory method called create Courier which is an abstract method here which is responsible for returning or creating the appropriate Courier object right so we can make the also abstract and for each type of Courier let's say we want a national Courier the national Courier class can extend The Courier Plus and we can have functionality specific to National Courier Services similarly the international Courier can extend the career class and we can have functionality specific to International couriers right and for each of these career types we have the corresponding delivery classes right so in this case the national delivery it extends the abstract class delivery and hence we are also extending the or we are providing the implementation of the abstract class create Courier and the factory method so create Courier is the factory method right which will return a courier of type National Courier similarly international delivery it extends delivery and similarly it implements the factory method and in this case it returns an it's it returns a courier of type International Courier so it creates a new international Courier object now let's look at the main method now that we have seen the abstract classes and the other types of classes let's see what's happening in the main method so in the main method as opposed to before before we are creating a Courier object in the main method right whereas here what we are doing is we are creating a delivery object d right and delegating The Courier object creation to the factory method right so D is of type international delivery and when we call D dot create Courier it is actually calling the international delivery classes deliver method right sorry create Courier method and it is returning an international Courier object right so to reiterate what we are doing here is we are creating a delivery object and the delivery object calls the factory method create Courier in this case so create Courier returns a career object of type International Courier right and this is then passed to the deliver method of the deliver object right so what is the advantage of using this Factory design method is that now let's say I want to extend my Courier Services to let's say local couriers right so all that I have to do is create the appropriate classes and call the factory method create Courier call the appropriate Factory method and it will create The Courier Service for me The Courier object form so in this way it makes the code more understandable and more extendable now that we have seen what the factory design pattern is let's look at some of the pros and cons so what are the pros what are the advantages of using this design pattern one is that this helps us follow the single responsibility principle so recall that single responsibility means that each class has a single functionality or responsibility to perform and second it follows the open close principle which states that classes should be open to extension but closed for modification so let's examine these with the code which we have right so before implementing the factory pattern let's say I wanted to include national International as well as local courier services I would have to do that in The Courier class itself right so in that way The Courier class is taking additional functionalities and responsibilities whereas here I create classes for each type of Courier Service right as well as I delegate creation of these to the Factory methods of other classes right so in that way each class is performing a particular functionality and now if I want to extend The Courier Services to additional types let's say a local delivery I need not modify existing classes I just need to add or add additional classes to implement the functionality so in this way we see that the factory design pattern encourages single responsibility as well as the open close principle now what are some cons of using this design pattern so you might have observed that the code can become complicated right there can be a lot of new subclasses which are added and this can make the code a little more difficult to understand so hence we need to decide or make a trade-off as to whether we need to apply this Factory design pattern or not based on the context in which we are writing the code now let's look at another creational design pattern known as the Builder design pattern so let's take an example so let's say I have a book class and I need to create a book object with some mandatory parameters and some other optional parameters so in this case let's say that ISBN title and cost are mandatory whereas author published and description are optional fields right so in order to create such book objects I need to call different types of Constructors right so let's see how we can implement this so in the code here we see that we have a class called book right which has some mandatory parameters as well as some optional parameters and this is a Constructor which includes all of the parameters but let's say I just want the ISBN title and cost this is another Constructor which can be used and let's say I want I want only the description the author and the year of publishing is null then I can use this and if the description I know alone is null then I can use this Constructor so are you seeing the issue with this So based on the parameters which we have we need to create different types of Constructors for different combinations right and this is known as telescoping Constructors you create multiple types of Constructors and this can make the code a little complicated right so let's see how we can use the Builder design pattern to solve this problem so the Builder design pattern tells us to extract the object construction code out of its own class right so we separate out the object construction code and we move it to a separate object known as a builder object right so if we take the example of the book class so we create another class called Builder which has the same Fields as the book class right and in addition to that it has methods like author so this isn't this method is nothing but the method which initializes the author field the published method is nothing but the method which initializes the published field and the same for description so for each of the optional parameters we have additional methods right which initialize those fields and we have a build method which finally builds the object and returns a book now let's look at how we can implement the Builder design pattern thank you so this is the code for how we can implement the Builder design pattern so as you can see we have the same class book right with the mandatory as well as optional parameters in addition to that we create another static class called as Builder which has the same parameters the the mandatory as well as the optional parameters and we create a Constructor called Builder which takes the mandatory parameters right and then we create methods which build individual parameters so for example this method called author we can rename it to something else like author builder for example so author Builder just takes a string and assigns it the value of author the same for published here and description as well right and we have the build method right which returns the book object right and here we can see that it is calling a Constructor and we will look at what this Constructor is below so the additional Constructors which were there earlier all those have been removed and it's replaced by a single book Constructor right which takes the Builder object as input and assigns the values for each parameter right to reiterate we see that we have the book class with the optional mandatory and optional parameters we create another Builder class with the same parameters we create a Constructor for the Builder which has the mandatory parameters and individual functions for the other optional parameters and we have the build function which returns a new book object and we remove all the other Constructors for the book class and we keep a single Constructor which takes the Builder as an input parameter and assigns values for each of the fields and now in our main method we see that we are creating a new book object right and we are calling the Builder Constructor which which initializes the mandatory parameters right so this function is this one right so ISBN title and cost are initialized and then we call the individual functions right so let's say if I want to assign author published as well as description Fields I call individual methods which are part of the Builder object right and finally I call the build function right so remember that the build function it will return the book object and that gets assigned to B1 right so if you see Book 2 in this case we are just creating the description for the book whereas the author and the published here is null right so we just need to call the description function and the build function and build will return a book object with description set to this and author and published here set to now so what are the pros and cons of the Builder design pattern so the pros are one it helps us construct objects step by step right so we saw that we can construct this book object by initializing each parameter right so as opposed to calling lengthy Constructors right and the other Advantage is that it follows the single responsibility principle of separating the task of object Creation with other responsibilities right so the Builder class takes care of building the object and the actual object now can focus on other aspects required of that class now what are some drawbacks or disadvantages of this design pattern well the key disadvantage is that the code may become more complicated right so as we saw we need to needed to create another Builder class with the same parameters right and additional functions as well and if you feel that in your code you do not have many mandatory and optional parameters then it might be okay to not use this design pattern