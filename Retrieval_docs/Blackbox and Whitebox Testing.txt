we looked at unit testing so we saw that in unit testing we test individual functions or units of a program and now in this video we are going to look at different ways in which we can do this and two ways in which we can do that is through Black Box testing and white box testing so we saw earlier that in Black Box testing the program is like a black box right we are not looking what is inside the program whereas in white box testing we are actually analyzing the structure of the program so let's look at what Black Box testing is right and as we said earlier it is the program is viewed as a black box it is also known as functional testing and the key idea is to see how we can design test cases for Black Box testing right now we don't have access to the structure of the code so then how do we do it we do black box testing by examining the input and the output value pairs and we have no knowledge of the design or code that is required so what are ways in which we can do black box testing so the first thing which we really need to do is to determine equivalence classes now what are equivalence classes so the domain of the input values of which our program can take it is partitioned into a set of classes or which are known as equivalence classes and for each equivalence class the program behaves similarly right so in a particular equivalence class for every input data in that class the program behaves similar right so let's take the example of the minimum value function right so we have two parameters X and Y and we have to calculate the minimum now in Black Box we do not know the structure of the program right but can you think of what the equivalence classes will be for in this case so the equivalence classes are one set of inputs are where X is greater than y the other set of inputs is where X is less than y and the third equivalence class is where X is equal to y right and for every equivalence class for example X greater than y so like values like 20 10 50 40 right wherever X is greater than y we need to just choose one value from this entire set right the same thing for X less than y and x equal to y so now let's reflect on this question for a moment so let's say we have a function called is prime which takes num as input num is a positive integer and it returns true if num is prime otherwise it returns false so what do you think are the equivalence classes for this function thank you can pause this video and think about the answer before proceeding right so what do you think are the equivalence classes for this function so this function is checking if a number is prime or not right so for all prime numbers it will return true it should return true and for all non-prime numbers it should return false right so for all prime numbers for all prime numbers form one equivalence class because you can choose any one prime number from this set right to test if this function works properly and another equivalence class is the set of non-prime numbers so you just need to choose one non-prime number to test this function so now that we have found what the equivalence classes are another important thing which we need to do is do what is known as a boundary value analysis so as we write programs right many at times our tendency is to miss values which are at the boundaries right or the boundary conditions and many programmers many a times they get confused between which operator to put should it be less than or less than equal to right so some examples are like you know what should the range of values be in a for Loop right so in boundary value analysis we examine the values at the boundaries of the equivalence classes right and so in boundary value analysis we design test cases using the values at the boundaries of different equivalence classes so for example the function is prime which we just saw right maybe some boundary values are 0 and 1 right so these are some things which we can check as we design test cases using Black Box testing so to summarize in Black Box testing first what we need to do is from the requirements and specifications we identify the input and the output structures and the values right because we do not have access to the program or we are not checking the structure of the program and then we identify equivalence classes and then we design test cases such that we identify one representative test case from each equivalence class and then finally we design boundary value test cases now that we have seen what Black Box testing is let's look at white box testing so in white box testing we analyze the structure of the program right and how do we analyze the structure we use some heuristics right and one such heuristic is known as coverage which means that are we able to execute or are we able to cover all or almost all parts of the program and that is one thing which we will try to do as we do like box testing foreign so this is known as coverage based testing and there are primarily three ways one is to do Branch coverage second is multiple conditions coverage and another way is to do path coverage let's look at each of these in detail so what is Branch coverage so as the name suggests in a program there are several branches which a program can take right so if we have a conditional if we have a while loop or a for Loops or there are different conditions which the program can take or different parts which it can or different branches which it can take so we check that every branch in the program is accessed at least one right and this can be done by making each of these each of the branch condition to our thoughts for example let's take the minimum function right so if I want to calculate the minimum of two numbers I the condition here is if x is less than y right so to achieve Branch coverage I need to check when this evaluates to true that becomes one test case and when this evaluates to false that becomes the other test case right so test case one is when this evaluates to True which is take a pair where X is less than y and the other test case is when this evaluates to false where X is greater than y greater than or equal to in this case right so choose one pair of X and Y such that X is greater than or equal to y so this is one way in which we can achieve Branch coverage so Learners here is a reflection spot for you so this is the is prime function right which takes a number num and it returns true if it is prime else it returns false so what do you think are the test cases that will guarantee Branch coverage please pause the video here and think about these test cases before proceed foreign coverage as we saw we have to check that the condition at each branch it evaluates to true for one test case and evaluates to false for the other test case right so in this case for this to evaluate to true for this if condition at line number 2 for it to evaluate to True num should either be 0 or 1. so 0 or 1 is 1 Test case right and for this to evaluate to false right it's not 0 1 and now here in this case we have to check if num mod n is equal to 0 right so this should evaluate to true or it should evaluate to false right so when it evaluates to true that means the number is prime sorry if if this evaluates to true that means a number is not prime right so for non-prime numbers this evaluates to true and for prime numbers right it evaluates to false right so in this case we have one test case which for this condition then 2 for when it's a prime number two and three and four when it is a non-prime node right so these test cases they guarantee Branch coverage now the second type of coverage based testing is multiple condition coverage so in many cases right we can have composite conditional Expressions right and what we do in multiple condition coverage is to check that each component condition it takes true and false values right so we saw in the previous example of is prime so we have the composite condition like num equal to 0 or num equal to 1 right so we check for each component condition so here num equal to 0 is one component num equal to 1 is the other component so we check are we design test cases such that each component condition takes true and false values so in this case when number 0 the first part is true the num is 1 the second part is true so the test case is 0 comma 1 they achieved multiple condition coverage now another example is when a number is outside two boundary values right so in this example if you see uh we we want to do something when num is less than 50 or when it is greater than 150 right so when it is less than 50 and greater than 150 you do something otherwise if it is within 50 and 150 you do something else right so in this case let's see how branch coverage and multiple condition coverage how do they differ right so if we had this test case 49 and 100 so 49 will ensure that this is true right and do something will get executed so this ensures that the if condition is true and 100 ensures that the if condition is false so hence we have achieved Branch coverage whereas for multiple condition coverage we also need to check when this is true right so we have to add another test case 200 which will evaluate to True which will evaluate this expression to true and this remains false right and in this case we can see that in some cases a multiple condition coverage is a stronger testing strategy than Branch coverage now the third type of coverage based testing is known as path coverage so what happens in path coverage we say that the tests will it achieves path coverage if it can access all linearly independent Paths of the program at least once so what does this mean so we can see which are the linearly independent paths of a program by constructing what is known as a control flow graph of that program so let's take an example so this is the same function is prime right which takes a number and returns true if it is prime and if you see these are the line numbers and for each line number I have constructed a node right and the nodes denote the the line particular line number and an edge denotes if the control flows from that line number to the second lineup so for example we start from line number one then at line number two we can either go to line number three right and exit the program or the function or we can move to line number four and at line number four it is a for Loop right either at the start itself the condition is not satisfied so we jump to line number seven or we go to line five right and at line five either the condition evaluates to true in which case we exit the program exit the function by returning false or we go back to line number four right so this is the control for flow graph for this function right so what are the paths the paths are 1 2 3 right which is 1 2 and this and we come to this line number path is one two four and seven right which is one two then we go to the four and we directly this for the initial condition itself is false and we jump to line number seven another path is one two four five and six right so at line number five this evaluates to true and we exit the function and another path is one two four five right we come till here and then again we go back to four and then we and this can happen multiple times right we iterate through this Loop multiple times and then we come out at 7. so these are Parts which we determined from this control flow graph so now Learners here's a reflection spot can you identify test cases for each of these parts so each of these from each of these parts we can decide or construct a test case can you think what these test cases are for each path you can pause this video and write down your responses before proceeding so now let's look at the test cases for each path right so the first path is one two three right and look by looking at the program if num is 0 or 1 right this path uh the program flows through this path right so that is the test case for this path for one two four and seven right for the value 2 right the 4 we do not enter the for Loop right we directly jump out so 2 is a test case for that path and one two four five and six so when we reach 6 that means a number is not prime right and hence a non-prime number can be a test case for this path and then for a prime number right we have the path one two four five and it can go multiple times through this Loop and finally come out from 7. right and it since it returns true that means the number is prime the number should be Prime right so these are test cases corresponding to each path so another way to determine how many test cases and how many paths are there in a program or in a function is to identify the cyclomatic complexity so we looked at cyclomatic complexity in the previous videos it is nothing but the number of decision and loop statements plus one right so in this case we have num equal to 0 or num equal to 1 as one condition the for loop as having the second condition num modern is the third condition so we have three conditions so the cyclomatic complexity is three plus one which is equal to 4 and hence we have four paths and hence we need to have at least four test cases so to summarize in this video we looked at different ways in which we can do black box testing and white box testing and we can use these techniques for Designing test cases for our programs and modules