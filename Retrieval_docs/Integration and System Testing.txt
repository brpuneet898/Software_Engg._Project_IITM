we looked at unit testing so unit testing is when we test individual functions or modules of a program right and we saw various techniques like white box testing and black box testing which can help us do unit testing now in this video we will look at integration testing and system testing so what is integration testing so after we have finished unit testing that means we have tested each of the modules individually now we need to combine all of these modules or incrementally integrate these units and test after each step of the integration process this is known as integration testing so now let's look at integration testing in some more detail so when should we do integration testing so ideally it should be done when at least few or maybe even all the modules have undergone unit testing right so unit testing is done that means that the individual units are working successfully right so now the objective of integration testing is to detect errors at the module interfaces right so where can the errors possibly occur so hopefully errors within a module have been fixed because of unit testing now errors can occur when one module calls another module right so are there some errors maybe in parameter passing or you know bit come in the communication between modules that can be uncovered using integration testing so let's take an example right so in this case we see that there are modules M1 M2 M3 M4 and M5 and the arrows denote that the relationship between these modules right so for example M1 depends on M2 M3 and M4 so some M1 calls some functions in M2 M3 M4 right so if you let's say we have unit tested M1 right so module M1 has some non-docal data and it calls functions of M2 M3 and M4 right so now let's say we have successfully unit tested module M1 right so we have created drivers and stubs for M1 and now we need to integrate it with the other modules right so what do you think are ways in which we can integrate this module M1 right so let's reflect on this for a moment and can you think of ways in which we can integrate M1 with the other modules you can pause this video and think of ways in which we can do integration testing before proceeding okay so now let's look at some approaches for doing integration testing right so one such approach is known as the Big Bang approach right so as the name suggests right all the modules are integrated in a single step right so all the modules which have been unit tested are linked together in one go and tested right and what is the issue with this the problem is that it is difficult to localize or find which module has an error right so the error May line any one of these modules right and it can be expensive to fix right so hence this approach is Meaningful only for small systems right and it is never used for large systems which have several modules another approach is the bottom-up approach right so a large software can have several subsystems right so the modules of each subsystem are integrated first in the bottom-up approach right so let's say we have M1 M2 and M3 right let's say they are one subsystem and let's say M4 and M5 are another subsystem right now in the bottom up approach what we'll do is we'll integrate M1 M2 and M3 first right and we test and we do an integration testing we then integrate m4m5 and do an integration testing of M4 and M5 right and then we incrementally now combine all of these subsystems together right now in a pure bottom of testing it is not necessary to create stubs right why is that because we are directly integrating all the relevant modules right so we need not create you know or mock the calling functions of these other modules right however drivers are required right because we need to simulate Global variable calls right many of these variables might not be available even in the subsystem and hence drivers are required now another approach the converse is the top down approach right so what happens in the top down approach we start with the root module right the the module at the top and some one or two subordinate modules of the root module right and these are suitable for you know software which have various hierarchical levels right so the top modules are tested first then the modules at the next level are tested and so on for example in this case let's say let's assume that M1 is at the top right M2 M3 M4 are in the next level and M5 is at the bottommost level right so what will happen here is M1 is tested first right it is M1 undergoes unit testing right and then M2 M3 M4 are combined with M1 and tested and finally M5 is combined with all the other modules right now in a top-down approach right we do not require drivers right because we start from the top so hence all the relevant Global variables are available right at each stage however we need to design stubs right because at each level we do not know or if this module requires some other modules at a lower level right we need to simulate them or mock those function calls hence stubs are required right so for example when we combine M2 M3 M4 we need a stub which simulates M5 so that is the top down approach and finally we have a mixed approach right which uses both top down and bottom up testing so in this case integration testing happens as and when the modules become available right so this is a combination of both bottom up and top-down approach and we do it when the modules become available after unit testing now that we have seen the different types of integration testing finally we do system testing right where the fully integrated system is tested now there are various ways in which we can do system testing so one way is to Define who is going to test the system right based on who is doing the testing so for example we saw these types of testing right so Alpha Testing is done by a test team within the organization whereas beta testing is done by a select group of customers outside the organization and then we have acceptance testing where the system is given to the customer and the customer determines whether the system satisfies the requirements or the user stories and they decide whether to accept the delivery of the software or not now there are other types of system testing as well so let's look at some of them so one is known as smoke testing so what is smoke testing so in Smoke testing firstly it is carried out before the initial System test right so before sending it out to the for Alpha Testing or beta testing right we do smoke testing so basically we just check whether the basic functionalities are working right so a few basic test cases are designed and they are checked to see whether the basic functionalities are working right so for example in case of the seller portal basic functionalities like ad products let's say you want to add things to the catalog or to the inventory so are these basic functionalities working that can be done using smoke testing another type of testing is performance testing right so in performance testing we check whether the system meets the non-functional requirements so up till now in the unit tests and the integration tests we were looking at whether the system satisfies the functional requirements right so whether the functionalities are being met by the design system but we also need to check for non-functional requirements as well so for example one type of performance testing is stress testing right for example the volume of input data the processing time you know the memory all of these are tested beyond the design capacity right it is used to check for the reliability the robustness of a given software right for example we might simulate several transactions to the database right beyond the expected capacity so how does the database how does the system deal with such you know High volumes and this performance and stress testing and all is done to check for the performance reliability robustness all the non-functional requirements