weeks our Focus was on building the right thing right identifying the correct requirements communicating with the clients to get the right requirements and so on once we hone in on what is the right thing to build now our Focus shifts to building it right making sure that we have done it properly so we have decided the broad architecture of our system started the development now one important thing to do is to effectively test our system so that we are actually building the modules correctly why is testing important even seemingly simple errors like integer overflow can cause entire systems to crash there's a lot of data on how much effort and time and money has been lost because of simple bugs in software systems for example Airport System Failure or spacecraft crash many of these you can find in the extra resources associated with this video so here's a reflection spot have you tested a program what are the basic activities that you did to check if your program is working correctly take a moment think about the programs that you have submitted in past assignments and think about how you did the testing okay so now let's reflect on the basic activities you did while you tested a program right so usually what do we do let's say we have a program we provide some inputs we check the output and we see if the output matches the expectation or the required output if not we locate where the error is we identify the error and we fix the error and then we test again right and we saw some of these steps in our debugging video right and if you notice the first step which we do is we provide a set of inputs and this is known as a test case so a test case contains three things it's a triplet right it contains I which is the data input to the programming and then it contains the state of the program s right at which the data is to be input for example in the case of our online seller portal so after login let's say on the catalog page the user clicks an add item to the catalog and fills all necessary details and then let's say clicks on add item right now we are trying to test the functionality of this add item so this is the current state in which the program is in and the third parameter is R which is the result expected to be produced by the program or the system right so in our case we expect the catalog page to be updated with the new item when I click on add item now the set of all the test cases which have been designed to test a given program is known as a test Suite so let's look at a summary of what all activities are involved in testing so first we have the test suit design that is we come up with appropriate test cases and how do we do that we will look there look at that soon and then we run test cases and check results right so each test case is run and the results are compared with the expected results and if there is a mismatch between the expected results and the scene results that indicates a failure and these failures are noted down later maybe for debugging and this is usually done by a tester and reported to the concern developer and many a times the tester and the developer are the same right so the developer who writes the program is the one who tests it as well then we have to locate the error right so each test case which fails it is it has to be checked by the developer to look out for where the error is right and finally we correct the error we change the code and then we test it again with the test cases so the first step is to design test cases why do we need to design test cases why not just randomly test for a large number of random values in that way perhaps we might save a lot of effort so take a moment and think why do we need to design test cases or choose test cases carefully so it's necessary to design test cases for many reasons one of them is if we test for a large collection of randomly selected values or test cases it does not guarantee that you have caught most of the errors why not let us consider the simple program which calculates the minimum of two values OK we are comparing two values X and Y if x is less than y then the minimum should be returned as X else the minimum should be returned as y this is the correct program now let us say there is an error in the program and in the else statement again it says the minimum is equal to X Now by simple examination you can see that this is there is a flaw in it but suppose we were to test with randomly selected values you know where X is always less than y for example 1 and 2 or 3 and 4 or you know thousand and ten thousand and so on if the random set contains only such values it will not be able to detect this error so the error will be found only when a value comes in actual operation which does not in which Y is actually greater than x or Y is less than x right so it is important to design test cases carefully so having talked about random values we may think why don't we exhaustively test all the values now as you could imagine the domain of all input values in a software system is very large we cannot test for all possible values again so it is necessary to design a minimal test suit where each test case has a particular function its designed to catch a certain type of error now that we have understood that it is essential to choose the right type of test cases or design the right type of test cases how do we go about doing that one way is to analyze the input output behavior only right we do not look at the code at all for example in the previous program we just keep putting values where each pair has a different relationship with each other so we know what the functionality is the functionality is supposed to calculate the minimum so we provide two types of test cases where the first value is the minimum in one pair the second value is the minimum in the second pair and maybe a third pair where both the values are equal to see what happens OK this is known as Black Box testing the program is like a black box and we are not looking at what is inside the program how the code works and so on we are simply giving inputs we know what the program is supposed to do we are simply giving inputs we know what the expected output is and we are seeing whether the expected output is given by the program or not this is also known as functional testing so we look at Black Box testing techniques in the upcoming videos now that we have seen Black Box obviously there is another way which is the white box right so the white box testing is to analyze the structure of the program the idea is that the program is like a white box it is transparent you can look into it so this is also known as structural testing how do we do that again going back to the previous example where we are trying to calculate the minimum of two numbers X and Y if we look at the code and we analyze the code and design test cases such that every path of the code is taken so we will design a test case such that for one input the if branch of the code is taken and then for another input the else branch of the code should be taken and then we see what happens when we actually run the code so essentially what we are doing here is we are checking if all the paths of the program all the different paths that the program can take from its beginning to the end whether they are all covered by the test cases this idea is also called test coverage where you are ensuring that your test suit covers all the possible paths that the program can take again we will be looking at white box testing later in this week now there are different levels of testing as well so to start off you do unit testing where the individual functions or units of a programmer tested and once these individual functions or units are tested then they are incrementally integrated and tested after each step of integration and this is known as integration testing right and now after we have integrated all the units together the fully integrated system is tested right and this is known as system testing and there are different types of system testing one is Alpha Testing where the test team within the organization does the full integrated system testing or another type of system testing is beta testing where the entire system is given to a select group of customers then finally we have what is known as acceptance testing where we give the system to the customer and the customer sees if the system satisfies the requirements or the user stories which were communicated to the team at the start right and they determine whether to accept the delivery of the software or not and apart from these there are other types of testing like performance testing which is used to meet the non-functional requirements of the system so we will look at these different levels of testing also this week