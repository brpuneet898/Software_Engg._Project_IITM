discussed about some tools that we use for software development you are also introduced to Version Control Systems in this video we will discuss Version Control Systems in more details so first let's understand what are the problems that we are trying to solve here we know that software developers work in large teams so how to handle concurrent changes to a project by the team members how to manage several versions of the software is keeping multiple copies of source code away to go how to track the changes including who did those changes over time so we need a way to do all this efficiently let's understand this problems with examples consider that several developers are working on the same project one of the developers made some changes to the code that caused a failure to the system and the system refuses to start in this case other developers were working on the same project they may not be able to test their new code changes so either you identify and fix the issue immediately so that other developers don't face issue because of this failure but this could take a long time because you don't know how much time it will take to debug the issue as you don't have any changes to record it the second option is you just roll back the previous changes that cause this failure and take back the system to a previously running stable state but how to do that in the absence of a system that supports this that is a task that we don't know how much it will take so let's come to the second problem consider a company that has hundreds and thousands of clients of a software system and every client may have a specific feature requirement if not every many will have it so for every specific feature requirement that other clients don't need the company will create a new version of the software and these versions needs to be maintained and stored so again the same problem will you store complete copies of these of the code base for every version so we definitely need a tool to address these issues and that is where Version Control Systems are helpful so version control system is a system that helps in tracking and managing the changes to the source code or other documents and maintaining the versions of the code in software engineering Version Control Systems false under software configuration management so the version control system does not make a copy for each version they have their own mechanism either through divs or through snapshots to maintain several versions and other history okay so the features that a Version Control System offers are tracking and managing changes to the source code over time either through branching merging commits or through some other mechanism maintaining different revisions of the source code you would have observed uh version numbers for a lot of softwares like 1.2 1.3.1 2.2 or something bigger so these are all different or newer versions of the software labeled as numbers so Version Control Systems also helps in maintaining change history that includes tracking who changed what and when in other details so there are additional features the newer version Control Systems offer nowadays actually these features are integrated along with Version Control Systems including comparing different revisions they provide tools integrated for reviewing the code changes tools to track issues in your software and providing ways to collaborate development in thing so why are they important obviously they increase productivity because developers can focus on their sole task of development rather than worrying about all the development operations they support better communication and collaboration through several tools that we have just saw this A1 space on multiple revisions by storing snapshots or through divs and ultimately this results in better efficiency even as teens scale so nowadays the question is not whether to use it or not everybody use them the question is which one to use so let's come to types of Version Control Systems the first one is centralized Version Control Systems in these kind of Version Control Systems there is a centralized repository maintained on the server that everybody shares so entirely based on client server model a person who want to make changes checks out whole or part of the repository make changes push back the changes to the server and they are done examples of these kind of centralized original systems are per force SVN they are still in use in a lot of organizations but they are highly dependent on the server if anything goes wrong on the server the entire development could halt if the server is up and running again you may even lose entire history or repository if the backups are not configured for the repository on server the second type is distributed Version Control Systems which are more popular nowadays in this entire repository is mirrored locally that includes the full change history a centralized repository hosting service could be involved but the complete dependency is not on that basically everyone owns their own local copies of the Repository so let's understand about distributed once it control systems through one of the most popular distributed Version Control Systems that is get so why is this so popular because this is free and open source originally this was authored by Linus towards in 2005 for development of Linux kernel since then it has evolved a lot and the version today you see has a lot of lot more features the focus of get is on speed data integrity and working on multiple tasks simultaneously how do how these are achieved let's see we already discussed that entire repository is mirrored locally so if you have everything mirrored on Multi and you have multiple copies of the repository you achieve data integrity and it's very hard to lose data because you have multiple copies now the second point is nearly every operation is local because everything is mirrored including the change history so for example if you want to check some previous change and who did that you don't have to talk to server for these small operations so hence you achieve speed and we'll see later that git supports multiple branches as other Version Control Systems so they provide parallel development now how to use git so there are several ways you can use get the first one is through command line you can install git on your machine whatever operating system you are using git is available for it Windows Mac or Linux with IDs so there are a lot of IDs that have get integrated by default or you have plugins to integrate IDs get into IDs the third one we'll look at is the GitHub portal because that is what we will be using for our projects also okay so GitHub portal is the online repository hosting service that gives you a graphical user interface also to use git now let's see the git workflow so this is a simpler workflow the file can be in three stages modified staged or committed after you modify the file you move it to the staged area to the stage area means you have marked the file to be committed but it is still not committed committed means after you committed it means that the changes are committed to the local database now why do we have this staged uh concept here so suppose you have modified a lot of files and some files are modified just for testing to help test the new changes that you are doing but you don't want to put those changes to the your master branch so in that case you will move to staged only those files that you want to check in okay now let's see the commands to do these firstly you have two ways first is either you create entirely new Repository for that the command is get init this will initialize a new get repository in whatever current working directory you are after that you add some files in the initialize directory you have some files that are in modify State we call after that we will use the command get add file name this will move the files to the staged area after that the command is get commit with a message that describes the commit that you can refer to this message to understand the details of the commit later on so of this command will move the all the stage files the changes to the database the other way is that if there is already an existing repository and you have joined the development on that repository you will clone that repository to your local machine the command is get clone URL then the directory you want to clone it to after that the same procedure you can make changes to the file do a git add to move files to a staged area and then commit to push the changes to the database after that you can do a get push to push the changes to the remote repository because currently till now you are working on your local repository but whenever but when you are done you can push those changes to the remote repository using get push but you are not alone working on that Repository what if while you were working somebody else made some changes and you want to incorporate those changes from report remote repository to your local Repository so the command to do that is get pulled this will fetch and download changes from the remote Repository that are not in your local repository and update your local repository there could be conflicts we'll reset those things later so let's see some more git commands get a status this command shows you the status in the working directory and staging area once you commit the files get a status won't show anything about those files you get diff is a command that you can use to see the changes between commits and working three then next command is get reset head and file name once you have staged the file name and you decide not to include it in the commit you can use this command with along with the file name to remove that from staged area tool once you have committed a file but not yet pushed it to the remote repository and you want that file to be removed from the commit the command to do that is get checkout file name there is another use of this command that we'll see later but instead of file name the option will argument will change the next command is get log this could be very useful this is used to check the commit history let's see the workflow involving the remote Branch also now so firstly you have mirrored the remote repository as a local repository using the git clone command you make some changes then you do git add after that you move the files to staging area you commit the files that you wanted to add after that the get push that will this will push all the changes to the remote Repository then again you want to make some more changes and you want to check out the latest copy of the remote repository you do a get pull the get checkout Arrow at the last it shows the workflow where you had some files in the comment those are committed to your local repo but you don't want to push them to remote repo that so just get checkout command is used along with the file name this will bring the file from the committed state to and change the state now the workflows that we have been discussing describes the workflows that involves only one branch but get provides a way for developers to work on multiple tasks simultaneously and also multiple developers to work simultaneously multiple developers are working on different tasks individually also at the same developer can work on several tasks simultaneously how do they do it they do it through branching you can create multiple branches in gift but still you will need a way to bring all the changes together because ultimately you are building a software and you want to bring all the changes and create a build of the software that has all the changes that you desire okay so we have the concept of branching and merging what is good branching branches are independent versions of repository they are the mechanism to diverge the work from the main project line so technically it is a pointer to a commit or a snapshot in git default branch in git is named as master so whenever you do in the initialization a default Branch name Master is always created so consider that Master branch is a main project line but everybody cannot work on the same Branch again the problem will be same how to manage conflicts and all the other issues that were discussed initially that's why every developer creates a branch of their own based that is based on the latest Master commit so you can get provides a way to create multiple branches and work on several tasks simultaneously for example get Branch feature one this command will create a new Branch named feature one from the base Branch you are working on the command gate Branch will list all the local branches that are available on your working Repository so now uh as discussed this is the second use of get checkout if you use the command get checkout with the branch name your working Branch will switch to that Branch for example git checkout Master will switch to master branch and get checkout feature one will switch to feature one branch the git checkout command can also be used to create a new Branch if you supply my hyphen B option along with get checkout Branch it will create the branch if it does not exist thank you so now merging so merging is a way to combine changes made through one or more branches to a single Branch as we saw that a lot of tasks are being completed through branches but you need a way to combine all the tasks into a single branch that can be used to generate a software building the command to do this is git merge feature one this will merge the branch feature one to the currently working branch okay so let's see an example so you are working on a new user story you created a branch named feature one to work on that user story from the branch named master then you make the requirement changes to the files and merge these changes to the master Branch so the commands are on the right side the First Command creates the branch feature one you make some changes after that get add suppose only one file host change you add that file to the staged area you commit the changes with some message after that you change your branch to master Branch use through the command git checkout master and then the command get merge feature one will merge the changes in feature one to master Branch now your master branch is moved to another commit and it has the changes that you did through the branch feature one but here this scenario we have created only one branch but you can create more than one branch and work on several tasks simultaneously here we are talking about the same developer now let's see branching and merging through a scenario that involves more than one branch so the scenario is you created a new Branch named feature one to work on a new user story you make some changes to Branch one but you have not yet merge those changes to the master branch before emerging and you are still working on the user story you have not done the complete changes there is a priority issue that was reported and that was assigned to you and you have to fix that immediately so what you will do you will create another Branch named issue p say to fix this issue you make changes to fix the issue and you merge the branch to Branch issue P to master so the issue is fixed but whatever you are working on those changes are in the branch feature one you again switch back to Branch feature one and resume your work that you are working on the user story now let's see the workflow of the scenario that we discussed the current Branch status before starting work on your user story consider the master branch is on some commit C2 there are two changes done in your project and you are on the master branch in the commit Master branch is on C2 you created New Branch named feature one from Master branch the feature one will be on C2 based on the commit C2 now you make changes to feature one and commit changes so a new commit will be created so let's name it that commit as C3 now your feature one branch is pointing to the commit C3 now as we have seen in that uh while you are working there was a issue reported and you started working on that issue through the branch issue B you created a branch it should be you made some changes and you committed those changes through Branch issue B so another commit will be created for that let's call it C4 so your issue p is on C4 feature one is on C3 and master is on C2 after that you are done fixing issue P so you have tested your changes those works so you will want to merge those changes to master the changes in the branch issue B you do that by the commands get checkout Master then get merge issue fee and then you delete the branch it should be using get Branch hyphen D issue B the key should be small in this command okay now the master will point to C4 it is moved from C2 to C4 now the changes in issue P are merged to master but those changes are not available in the feature one branch because feature one branch was created from Master when master was on C2 so we say that now Master is ahead of Branch feature one by one commit now let's try to merge uh feature and now let's try too much feature one into master so now you switch back to your user story task you make more changes and then you merge feature one to master using the commands get checkout Master get merge feature one in this case git will do a three-way merge if there are no conflicts else we'll have to resolve the conflicts and then do the merge so why are we talking about conflicts here so as we have discussed in the last slide issue P made some changes and a new commit was created as C4 Suppose there is a file named x dot py that was changed in issue p as well and you have changed the same file in feature 1 as well so why after that when you will be trying to do a three-way merge if the same file is changed in C4 and C3 it won't know which changes to keep in that case there will be conflicts and you will be asked to resolve the conflicts if git cannot resolve them now let's see what is gitree basic so get rebase command is used to incorporate changes from one branch to another let's understand why do we need this command through a scenario it is the same scenario that we just saw just that after step 5 there is a small change so till step 5 the scenario is same you create a new Branch feature one to work on a news story you make some changes to the branch a priority issue was reported and you have to fix it immediately you switch to another Branch issue p and you start fixing the issue just to note here you add a function remember Function One f u n 1 to the code through the branch issue B to fix the issue now consider the scenario when you switch back to Branch feature one and resume your work on your user story you realize that you are doing something wrong and now you need to call the function fun one in your user store implementation that is in the branch feature one so fun fun one code the function fun one was added through the branch issue P now those changes are not available in feature one as we saw in the workflow so what do you do the solution here is to do a git rebase so generally speaking even without fun one being there in the branch feature one you can call that function and you can make the code changes and you can merge it to the master Branch but the problem will be if one one is not available locally on your feature one branch you won't be able to touch the changes because it will give an error when your code will try to call fun one okay so to actually if you want to touch the changes you will have to do a get rebase what will rebase do it will incorporate the latest changes from Master Branch to feature one branch so see similarly uh as we talked about conflicts the conflicts could there be in case of revising also if this if same files are changed between through commits and get is not able to resolve those uh changes itself then you will have to resolve the commits and complete the rebase okay so the command to do this will be go now you have to switch to feature one branch and then you do get rebase master this will rebase your feature one to the latest comment on Master branch now let's understand this with the workflow for the scenario that we just saw the change scenario where you want to use fun one function in feature one to test the changes so till step 5 everything is same so let's consider the state after step five so this was the state your feature one was on C3 master was one commit ahead at C4 you do get checkout feature one and then the command gate rebase Master what will this do this will take your feature run Branch to C5 a new commit is created because you feature one has some more changes and it has rebased to the latest comment that is C4 master so everything that is in C4 will be in C5 along with the new changes that have been implemented in feature one now you can do uh get uh merge you can merge feature one to master and you know feature one and master both will point to the commit C5 after merging so for more details on get refer to the SCM get scm.com there is a book that has all the details about branching merging rebasing and lot more details now just a short introduction on how to use get on Ides so almost all popular ID support get so either it is integrated by default or through plugins so this is a snapshot taken from the Eclipse IDE uh there's a plugin that you can install for the eclipse to work with get so as it is a graphical user interface it's very intuitive and you can see the directory structure of your repository something like this and also there are options for all the command that we have seen so if you have understood the workflow it would be very easy to work using GUI on IDs and IDs also provide a way for command line if you want to use them now the Third Way is through GitHub so this is your online get repository hosting service as discussed this provides a web-based graphical user interface to manage your grid project created on GitHub you would already be using this for your projects so you would be already aware of some bits of it it also provides you access control you may have to give username and password to access your repository bug tracking that we'll see software feature requests we'll see task management continuous integration and you can also create wikis inside your project as a documentation for more details refer to the link