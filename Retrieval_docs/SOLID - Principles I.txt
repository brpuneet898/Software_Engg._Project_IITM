principles so solid principles are object oriented principles for Effective software design so these principles were conceptualized by Robert Martin popularly known as Uncle Bob and he is a very prominent figure in software engineering he is one of the founders of the agile Manifesto of the Agile development process and using these principles we can make our code easy to understand and modular and these principles support the concepts of good cohesion and loose coupling as well so let's look at these principles in detail now solid is an acronym s stands for the single responsibility principle o stands for open close principle L stands for liskov substitution principle I stands for interface segregation and D for dependency inversion now let's look at each of these principles in detail now the first principle is the single responsibility principle now as the name suggests every class should have a single responsibility or purpose right so every class in your Software System should have only one responsibility in the software system so let's take an example from the seller portal itself let's have a look at this class diagram which contains only a single class so the seller class contains information about the seller the seller ID the name the address and about the product and it has functionalities related to now adding a seller deleting a seller adding products right as well as deleting some items from the inventory adding items to the inventory and viewing an inventory so Learners let's reflect on the design of this class diagram right do you think it is following the single responsibility principle can you identify different functionalities which are embedded into the single class so as you would have noticed this design it violates the single responsibility principle right the reason being you have functions and attributes related to the seller related to the product and related to the inventory right so let's see how we can refactor this code so refactoring means how can we change this code so that it follows the single responsibility principle so what we can do is split that big seller class into three different classes right the seller class contains details only about the seller an appropriate functionalities related only to the seller like add seller and delete seller then we have a product class which has details regarding the product and the inventory class takes the seller ID as an attribute and different products gets added to the seller inventory so in this way each class has a single responsibility or purpose so let's look at how we can implement the single responsibility principle in our code so the code on the left here it contains a single class called seller which has attributes and functionalities related to the seller the product as well as the inventory right and our main method in our main method we create a single seller object and that calls all the necessary functions and here we see that the seller class is actually violating the single responsibility principle so now the code on the right we divide or we split the seller class into different classes right so we have a seller class which takes attributes related to the seller we have a product class which takes attributes and functions related to the product and we have the inventory which takes member functions related only to the inventory so in this way we have split a monolithic class into separate classes and each class performs a single responsibility and now in the client we create separate objects for a seller for a product and for the inventory and for each of these objects we call the appropriate member function the advantage of this code is that let's say we wanted to make some change in the product class or with attributes related to the product right so in that way we need not modify any of the code related to the seller or the inventory in a major way right and as Developers it is easy to identify mistakes in our code because the code is isolated in terms of different classes and objects and let's say we have to if there is an error related to the product class right so we need to just look at the product class and modify member functions related to the product class now that we have seen the single responsibility principle let's look at the next principle which is the open close principle so according to the open close principles software entities should be open for extension but it should be closed for modification so what does this mean this means that whenever we write code we should make sure that we are only extending a classes behavior for example by creating subclasses Etc without modifying the existing glasses so let's take an example so let's say we have a product class right which has product attributes like the ID name type and cause now let's say I want to add a new product type for example clothing so a clothing product like a shirt will have additional parameters like the size the color Etc right now one way to add a new product type like clothing is to make changes in the existing product class right so I can add size and color attributes and I can add a new member function called add product which takes the size and color as well now this design actually violates the open close principle so in this case we are modifying the product class by adding attributes to an existing class so learners what can be done to this design so that it does not violate the open close principle so now let's see how we can implement the open close principle for this design right so what we can do is create another class called clothing which inherits properties of the product plus so clothing is a subclass of product and whichever our attribute specific to the clothing plus that can be defined in the clothing class so the clothing class inherits these attributes like product ID name type cost as well as it has specialized attributes like size and color so in this way we see that our product class is untouched but we are extending the class by adding a new class called clothing in this way our design it satisfies the open closed principle now let's see how we can implement this principle in our code so the code on the left you can see that we have a seller class and we have a product class and initially we just had the product attributes and now if I want to add attributes related to clothing one way which I can do that is make modifications into the existing product class so I've added two attributes here called size and color and I create another function called add attribute which takes the size and color and in my main method I create a product P1 and I create another product object called short one which calls the appropriate add product function and it inputs the size and color as well so this code is actually violating the open close principle because we are modifying an existing class and adding additional attributes so let's see how we can apply the open close principle to this code so the code on the right here we see that the product class does not change right but we create an additional class called clothing which extends The Base Class product and we add specialized attributes called size and call and we create or we extend the add product functionality here and we include the size and color to this function so in this way we see that the existing class is not modified it is not modified at all whereas we have extended the functionality for specialized classes so another Advantage is now let's say if I want to add another product called book I can do that by following the same principle so here I have attributes called author and publisher and I have another member function called add product which takes these attributes and in the main function all that I have to do is call or create objects for those specialized products so here I create a clothing product clothing object here I create a book object right and call the appropriate methods in those objects now that we have seen what the open close principle is let's look at the next principle which is the list of substitution principle so the list of substitution principle generally works and is applied to inheritance hierarchies where you have a base class and you have derived classes which extend the functionality of the base class now the list of substitution principle states that the derived classes they should be substitutable by their Base Class so what this means is that let's say we have a derived class D and D is a subtype of a base class let's say B and what list of substitution principle says is that we should be able to replace methods in the base class with the methods in the derived class without interrupting the behavior of the program so this might seem a little abstract so let's take an example so let's say we want to implement a feature where we want to notify sellers about feedback regarding their product and we want to notify sellers through email so here is one possible design which implements this feature so we have a product class and we have an abstract class known as feedback notification which has an abstract method called notify right and the email notification class extends the feedback notification class and the notify method here actually implements the feature of notifying sellers about the feedback through email now let's say I want to extend this feature and now I want to notify sellers through email as well as SMS so what we can do is create another class known as SMS notification which extends feedback notification right and we can implement the logic of how sellers will be notified through SMS in the notify method however there is a slight issue here right so if you've noticed the third parameter is email and here instead of email we need to have an a mobile number field right since we are going to send an SMS to a particular mobile number and not an email so here this design is actually violating the list of substitution principle because the method in the base class cannot be substituted by this method in the derived class right so Learners let's reflect on this for a moment what changes should we do in this design so that we can follow the list of substitution principle so what we can do as we notice that this email field was causing issues right so we can remove that field from the abstract class and we can create derived classes and add the necessary parameters there so for example we'll have an email notification class which has an additional parameter email we'll have an SMS notification class which will have an additional parameter mobile number both of these classes extend the feedback notification class and if you look at the method both can actually implement the abstract method from the base class so in this case you can see that the methods in the derived class can be substituted by the methods in the base class in this case and so this design follows the list of substitution principle now let's see how we can implement the list substitution principle in our code so the code on the left is the code before we apply the list of substitution principle so we have a class product and we have an abstract class feedback notification which has a notify method which takes feedback about a particular product and the feedback is in the string and we send it to a particular email and now the email notification class extends the feedback notification class and implements and provides an implementation for the abstract method notified okay now as we said if we want to send SMS notifications as well we can extend the feedback notification class however the issue here is that the notify method has a parameter called email right and that is not compatible with the derived class for a derived class SNS notification because instead of an email we now require a mobile number right and hence the derived class method is not compatible with the Base Class method and even in the main code the email feedback notification method works fine because we are sending an email as a parameter but for SMS notifications the notify method will not work because we are sending a mobile number instead of an email now let's see how we can use the risk of substitution principle here right so what we will do is in the feedback notification abstract class now the base class we will not include the email parameter but include the email parameter as a parameter which is specific to the email notification class and here the as before the email notification class extends feedback notification and in the implementation of the notify method we are just taking the parameters the product and the feedback right and through the Constructor of email notification we are setting the email parameter and here we are using that parameter in the notify method now similarly this will work for SMS notifications as well right so in SMS notifications we create specialized parameters called let's say mobile number and carrier and we initialize this during the object construction time and we can call the notify method which just takes a parameters product and feedback so in this example we can see that the methods in the derived class can be substituted by the methods in the base class right they are substitutable they can be interchanged without breaking the code or without causing any disruptions in the code so this is an example of the list of substitution principle and now in the main method we can see that we create an email feedback email notification object right and we pass an email as a as a Constructor field similarly we create another object called SMS notification which has parameters of the mobile number and the carrier right and the notify method is the same as that of the base class in this way we have refactored our code which did not follow the list of substitution principle into a code where the derived classes can be substituted by methods in the base class