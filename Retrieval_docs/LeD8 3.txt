we looked at some of the solid principles we looked at single responsibility open closed and the liskov substitution principle in this video we will be looking at the remaining two principles in the solid principles acronym we are going to look at I which is the interface segregation principle so first what is an interface right so an interface is nothing but a group of related methods right with empty bodies so we do not write the definition of what these methods do we just specify what the interface should do what the methods are but not how we are going to implement these methods other classes can implement this interface by implementing all the methods in that interface so what is the interface segregation principle state it states that we should not force any client to implement an interface which is irrelevant to them so what does this mean this means that if we have an interface we should make sure that all the methods in that interface can be implemented by a client so if there are some methods which are not relevant then they should either be removed or they should be placed in another interface so it should be segregated such that an interface performs the actions specific to that interface only foreign so let's take an example so let's say we have a feature where we want to process the delivery of an order so what does this mean so we let's say we need to process the order we need to notify the seller package the order and send it for delivery so this is a class diagram right which implements this feature so we have a seller class and a product class and the delivery processing here is an interface right which has methods like place order you notify the seller you package the order and you deliver it now client can implement this delivery processing interface and write definitions for each of these methods right to implement this feature of processing the delivery however there is one issue with this interface right let's say we have online orders or we have orders in which you have a digital product for example an e-book right such orders you need not actually package them right and you need not deliver them to a specific physical address so if there is a client who wants to implement an a delivery of an e-product right these two methods are irrelevant to them right well they can of course implement the delivery processing interface but not have any meaningful implementations for package order and deliver in this form so Learners let's reflect on what refactoring or what changes need to be done can you think of how you can apply the interface segregation principle in this scenario you can pause this video and think about this before proceeding so as this principle suggests it is necessary to segregate or split this interface the delivery processing interface right so what we can do is create two interfaces one is for a physical delivery and the other is foreign online delivery right and the physical delivery processing interface Remains the Same as the previous one right where you have placing an order notifying seller you package the order and you deliver it to a specific address whereas an online delivery processing interface can have for example the place order and the notify seller can be the same right but you do not require a package order or a deliver order method so now if a client wants to implement an online delivery order they just have to implement the online delivery processing interface and if some other client wants to implement physical delivery then just need to implement the physical delivery processing interface so the key idea to note here is that it is necessary that we segregate or split our interfaces such that each interface performs a particular function right so we should not force a client to implement any of our methods which is irrelevant to them in an interface now let's look at the final principle which is the dependency inversion principle so this principle states that a client or when we write code we should always prefer abstractions or interfaces over specific implementations we should always prefer abstractions over implementations so what does this mean right so let's take an example so let's say we want to implement a feature where a seller should receive payment of his or her products sold through the seller port right so to implement this feature I of course need a seller class right with seller attributes and some seller methods for adding and deleting a seller and bank account is one of the attributes of the seller right and a bank account can have Account Details like the number the branch the balance and all of that right so now let's say I want to extend this feature and now let's say I want to receive payment via other mediums like paytm Google pay or UPI Etc right so I will Implement classes for each of these payment methods right now let's see how we can implement this in our code so as we saw we have a class referring to the seller right which has attributes of the seller then we have a bank account class which has attributes regarding the bank account and we have specific classes like Google pay paytm UPI for each payment method right and each of them have a payment method which you know processes the payment based on that method right and now if a client wants to implement this the client here create so let's say I want to implement a bank account type of payment then I create an object of bank account and I and I create a seller and Link this bank account object with this seller right so as we saw a seller has a attribute called bank account right which is nothing but a backup bank account object now do you see what is the problem here now let's say I want to create another seller let's say S2 right and now I want to add the payment method for this seller as let's say UPI right but now the issue is so then I will have to create or I might have to add another attribute for UPI here right because currently seller is tightly coupled with the bank account class now similarly if I want to have the seller associate with other payment methods like Google pay paytm UPI I need to couple the seller with these classes or these objects as well right and this is a issue right and this is making my code unnecessarily complex so Learners let's reflect on this for a moment what changes do you think we need to do so that we can link a seller with different types of payment so the question is here seller and bank account are tightly coupled now I want them to want it to not be so tightly coupled I want to allow the seller to use other payment methods as well what changes will you make in this code so this was a code initially Now using the dependency inversion principle what we'll try to do is decouple the seller with a specific implementation of the payment option right so here you can see that the seller is tightly coupled to the bank account payment option so to do that we will create an interface an abstract class or an interface and now the seller is coupled to this interface so as you can see instead of bank account which was there previously now the seller is coupled with this interface known as payment account now we have specific payment options like bank account UPI Google pay Etc which implement this interface which is a payment account now let's see how we can implement this in our code so the code on the left is our previous case now let's look at the code on the right so here I have included an interface a very simple interface for this example called payment account which has a method called payment and I have different payment options like bank account Google pay Etc which implement this interface and unlike the previous case where the seller was tightly coupled to a specific payment option like the bank account here the seller is coupled with the payment account interface now let's look at the advantages of this right now in the main method I will create a payment account object and based on the payment option which the seller wants so let's say the seller wants money through a bank account I can create an object of type bank account and pass that object to the seller now whereas later on if I want to include a new payment option like UPI all I have to do is create an object of type UPI and make and call the payment method right and this will definitely work the reason being we have decoupled the seller with the specific type of payment option that we want and hence this follows the dependency inversion principle which tells us that we should always associate classes with interfaces rather than the actual implementation so we saw what the solid principles are and whenever you write code make sure that you follow these principles this will make your code more more efficient and maintainable and easy to understand now in the next videos we will be looking at more specific cases known as patterns where you will see these principles coming up again and again the next videos we will discuss design patterns