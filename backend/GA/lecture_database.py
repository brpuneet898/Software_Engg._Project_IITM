
lectures_db = {
    1: {
        1: ['https://youtu.be/hKm_rh1RTJQ',
        "welcome to this course on software engineering we all know the importance of software today but we need to know how to build such systems and how such systems are built what do we have to do in terms of thinking about users how do we do the coding how do we do the testing and so on and so forth so this course is a primer to understanding how to design such software systems how to do some of the implementation and some aspects of the testing and so on so what are the expectations from you as a learner you are expected to put in at least six hours per week on the course so that you can get the maximum out of it and from our side we will ensure that there are activities and there are dialogues that happen throughout so that you do not feel that it is one long monolithic video that you are watching so what is software engineering so if you look at the history of software engineering it started off as an art so you had good programmers who wrote good code and you had bad programmers who did not write good code and over time the expertise of these good programmers they were documented over time which led to processes models and strategies for effective software development and thus the field of software engineering was born so in this course we will be looking at three important categories of topics so one is the software processes so what are different processes which are used in software development you will be learning about processes like the waterfall model the agile model and what are common practices in these models which are used in the industry a second category of topics is tools right so what are tools which software teams use to build software for example what tools are used to capture requirements how is software planning done how is development done how is testing done so throughout the course you will be learning about different tools which are used in the software development process and third we will also be talking about code we'll be talking about how you can organize your code what are best practices for writing clean and effective code this course has been created using a learner centric mooc model what does that mean it means that instead of simply having all the lectures in the beginning followed by all the assignments followed by the exams what we have tried to do is to interleave these in a way that is meaningful for you to maintain your engagement for example there might be a video in which there might be a pause where we ask you to think about something and maybe write down your thoughts so this pause is very important for learning and that is called the reflection spot similarly the videos might be short and immediately after the video we might want you to do some activity ok so these are learning by doing activities again which are very important for learning then there will be discussion forums in which we will post questions to focus your discussion so that you can have a focused discussion instead of a scattered one and finally there will be lot of resources which will cater to your exploration in the direction of your interest for example some people may be more interested in coding whereas some others may be more interested in how a software behaves actually in the field whereas the third set of people may be more interested in talking to users of the software another key aspect of this course is the course project and through this course project you will be able to go through the entire software development lifecycle so a software engineering course it can be very theoretical and the best way to get an understanding of what all you learn is to apply the processes the practices the tools in building an actual software so in each week you will have some intermediate milestones which you need to complete to progress towards the goal of building a software product so we hope you have a great time in this course and happy learning you"],
        2: ['https://youtu.be/81BaOIrfvJA',
        "we are all familiar with buying things on an online platform like amazon we are familiar with ordering things online and we are not surprised when the goods land up at our doorstep behind it there is a huge system which actually makes this happen so there is the vendor who is putting the things into the system there is a logistics person who is trying to handle ensure that the item reaches you in a timely manner and so on now how do you think this amazon system was built do you think it was built in one monolithic way so in most cases software is not built as a monolithic system but it is built incrementally one feature after the other and moreover often times we do not know at the start what all features are required to be implemented yes that is a good point so we incrementally build certain features into the application and the one the people who built amazon would have also done the same thing and even for building these features software teams have to ensure that they are divided into manageable components so components are a way of breaking the complexity of a system into manageable parts so that different teams can work on different components of the system and put everything together in a timely manner also everyone need not know the workings of all the components as long as i know that if i ask some response from a component and i know what sort of response it will give me that is sufficient for me to proceed with my work so the components can hide the complexity of the implementation and provide an interface to others who want to know what the component does now let us think about the components in the amazon system what do you think are some of the components can take a minute pause here think about what could the components in the amazon system be if you were the one of the developers of that system so i think one major component in the amazon system is of course their inventory management system so they keep track of their inventory in such an intelligent way so learners you might be wondering what do we actually mean by any by intelligent so let's think about what inventory management is so inventory management is the act of measuring the amount location pricing the mix of products available on amazon so when we go to the amazon home page we see that our inventory gets updated based on the current purchasing and seasonal trends and fluctuating customer demand and logistics and analytics also play a large part in inventory management so it is very interesting to see how my amazon home page could be very different from yours the reason being amazon customizes my home page based on my shopping and viewing history another component can be their payment gateway so the payment gateway is another component which offers ease of payment for both buyer and the seller so payment gateway is a service that authorizes the electronic payments like online banking debit cards cash cards etc so the payment gateway acts as a middleman between the bank and the merchant's website or application when a user wishes to make a payment the amazon website sends the encrypted card information to the payment gateway then the payment gateway confirms the validity of these details with the bank and the required amount of money gets transferred from the user's account to the amazon account so we looked at two components of the amazon system the inventory management and the payment gateway i am sure you can think of more components that makes up such a system so in this video we looked at components of a large system such as amazon and we looked a little more closely at two components the inventory management and the payment gateway the main thing that we have learnt is that nobody builds a system all at once for the entire functionality of the system so a system a large system is broken down into components and there are different teams that work on those different components each of these components now is called a module and they can be developed separately and integrated together later of course there is a lot of complexity in doing so because you need these modules to be able to talk to each other and so on and that we will see in the following videos you"],
        3: ['https://youtu.be/SU2CBhSFUUA',
        "in the previous video we spoke about the amazon website and identified some components that it's made up of the key idea we wanted to convey at that time was that a software system is made up of different different components which interact with each other to provide the functionality of the entire system now it is also interesting to understand how each of these components are implemented so for example let us look at the amazon wallet right which is known as amazon pay which stores your money and using which you do transactions how do you think the amazon pay feature is implemented let's take a look amazon pay is a mobile wallet a mobile wallet is a way to carry cash in digital format you can link your credit card or debit card information as well as your bank accounts to a mobile wallet application or you can transfer money online to your mobile wallet instead of using your debit or credit card to make purchases you can pay with your smartphone which has this mobile wallet there are many categories like recharges bill payments travel and insurance rewards gift vouchers and so on a mobile wallet has features such as adding money and auto reload as well so how do you think they started building the system how did they come up with these functionalities what do you think is the first step in creating a software system this is the key idea right what is the first step that we need to take can pause here think about it for a moment and then proceed so some of you would have thought that we first need to learn a programming language yes that is in a way true you need to write code for the software component using a programming language but even before you start thinking of the solution you need to think of what problem you want to solve so another answer which you might have said is that we need to study existing components of the system for example other components of amazon like the inventory management the payment gateway and this can give us an idea of how the this amazon pay feature will interact with these components maybe i can also look at other wallet systems like paytm phone pay etc and see what features they have all these are valid answers we need to first understand what is the problem we want to solve and based on an analysis of existing or similar systems we need to come up with an explicit set of goals for our own system or for what our implementation should provide so these goals are called the requirements of the system and this is usually the first step in the software development process so ultimately the software component will be used by different types of users and these users are known as the clients and we need to ensure that the requirements cater to their needs so who is a client does it mean that the client is the end user or does it mean the client is somebody who comes to buy something that's the usual understanding of the term client however when we look at a software system it is not always that the user is external to the system clients could be internal users also for example a client can be one component of the system could be also a client of another component so client can be an external user and this is the most typical way to think about clients for example a mobile banking software serves customers of the bank by providing various banking features such as checking the account balance and transferring money a client may be internal to your company as well for example a company might want to build an employee resources portal which contains information about various employees and teams in the company to build such a system the company might form an internal products team which communicates with other departments like human resources to understand the requirements now the client can be another software for example a payment gateway like razer pay interfaces with another e-commerce website or app to handle customer payments and refunds customer details are sent to the payment gateway by the e-commerce website and then the payment gateway communicates with the customers bank and sends the response back to the e-commerce website so the important thing to note is that we need to think about who is going to use our software for what purpose and in what way this persona of the intended user must be alive in our mind as we think about creating software to summarize the first step in the software development process is to gather requirements why is this step important because this is the step that ensures that we have a good understanding of the users or the clients of the different components of our system we need to ensure that these requirements are met at every stage only then the entire software will meet the end users requirements"],
        4: ['https://youtu.be/iNqfWUN_hrc',
        "in the previous video we talked about the first steps of software development cycle namely gathering of requirements so what is the next step most people would think ok i am ready to start coding and they would jump to writing code is that really the next step let's see this with an example imagine that you are a small team going to implement the amazon pay feature from the requirements all of you are really excited to start implementing right and directly jump into coding what difficulties are you likely to encounter pause here for a moment and think about it and write down one or two difficulties that may arise if we directly jump into coding after gathering the requirements so one issue can be that different developers they have different ideas about how the functionality should be implemented so even if you have discussed about what should be done with your teammates you will most likely make changes in your code for example you might add an argument to an existing function in your code and this can result in an error in the code of your colleague which uses your function to develop her component and this can be more pro problematic when different components created by different people have to interact with each other and such a scenario can be a disaster it will needlessly make the software complicated and the product won't be delivered on time also if i want to add new features later on it would help to have a big picture view of the system so that i can decide how this new feature can be correctly integrated into the existing system so this big picture view of the system is created in the design phase of the development cycle ok we create this so that we know how to organize the code before we jump into implementing it and this provides the structure to the whole software system so after coming up with the design then we can go into implementing the system and write code so learners here is a reflection spot for you so what all comes to your mind when you see software developers writing code how do you think people work in this development phase you can pause this video and write down your responses before proceeding so when a feature is being implemented multiple developers work together and write code for the feature they use tools like github to collaborate and write code and very often coding is done in a distributed manner with developers working in different locations and even in different time zones hence it is very important that everyone working on the code base has a consistent understanding about what the code does and that's the reason why developers write documentation for their code and write precise interface definitions so now what is an interface an interface is a description of the actions that your functions can do without describing the implementation in detail the interface shows what requests are accepted and in what format the corresponding response is given that is the output the code being implemented by the interface can change as long as the interface remains the same so in the development phase software developers write code based on the requirements and the design of the software system development is usually distributed these systems are too big for one person or one small team to develop so multiple people write the code which implement the required functionalities often multiple people are sitting in multiple time zones to do this so to ensure now that we can put everything together and it functions everyone in the development team needs to write what are called interface definitions what does that mean it basically means that what is the language that two components can talk how do i expect a query what is the form that i expect the query to take and what is the form in which i will provide the answer so that is the simple way of thinking about interface definitions"],
        5: ['https://youtu.be/3uokL_BdoiU',
        "in the previous video we talked about the design and the development phases of software development that mean that we are now ready to release our software no there are two more phases that we have to think about one of them is testing and the other one is maintenance so here is the question for you why is testing so important what will happen if we do not do rigorous testing of our software before we release it so after the software system is built it's necessary that the software should behave according to the requirements and at this stage testing of the system is done and testing is important because many bugs and defects can still exist in the system and these bugs can result in a loss of lot of money so for example a study have shown that in 2002 software bugs caused the u.s economy around 60 billion in losses and in 2016 this number jumped to 1.1 trillion and the failure to address bugs can even cause severe catastrophes and you can find more details about these in the additional resources which we have provided so how is testing done so testing is done at different granularities so one type of testing is known as unit testing so unit tests they focus on a single part of the whole application in total isolation usually it's a single class or a single function which is tested integration testing is another type of testing in which after now you have tested the individual parts you now test how parts of the application work together as a whole and finally you have acceptance testing where you check whether the requirements of the users are actually met by testing the application with end users and there are two types of acceptance testing alpha testing and beta testing so alpha testing is done by internal employees in a lab or a staging environment and the goal of the alpha test is to catch as many issues as possible before the product has been released to the public and then there is beta testing beta tests are conducted by actual users in a real-life setting and after adequate testing the feature is rolled out but it is necessary to monitor how users are actually using that feature are they using it the way we intend or is something else happening we have to see if there are any difficulties or errors that they encounter all of this is done during the maintenance phase okay so the purpose of maintenance can be one to monitor what the users are doing and how they are using the software two to change the code for upgrades now we are all familiar with this push of a patch release right so that is the maintenance phase of any software and the third important thing is when we want to add features so we are all familiar with several software where features have been added as we kept using them let us see this with an example so let us think about our amazon pay example so even after releasing this feature what difficulties or errors do you think users will face there can be issues like for example some conditions might have been missed resulting in failures or maybe a simple ui issue in a very specific browser so the team identifies such issues in the maintenance phase and continues this process to fix such issues so in the previous videos we looked at different phases in the software development life cycle we looked at how we should gather requirements then how we should come up with the design the development phase the testing and the maintenance phase so in each of the following weeks in this course we will look at each of these stages in detail we will look at the tools the best practices in each of these stages for example what are the tools used to gather requirements what are the practices for designing software in the development process and so on"],
        6: ['https://youtu.be/938T0bC7ls0',
        "in the previous lectures of this week we looked at various phases and activities in the software development process we also looked at why these phases are important so learners many of you might have developed software projects before right so let's reflect on how you went about developing software you might not have strictly followed the process of identifying requirements then coming up with the design then writing code testing it and so on so you might have followed an exploratory programming style so this is commonly known as the build and fix type of programming and here programmers they typically start to write the program immediately after forming an informal understanding of the requirements and once the program is complete then they fix anything which does not match the user's expectation and this was how programming was done in the early 1950s and 60s so good programmers they knew certain principles that help them write good programs and these principles could be things like you know thinking thinking about the big picture view of the system which is the design before you actually start writing the program and over time these good principles and practices along with research innovations they have been systematically organized into what is known as software engineering today so software engineering emphasizes software development through a well-defined and ordered set of activities and these activities are commonly referred by various names such as the software lifecycle model software development lifecycle or sdlc and the software development process model so the software life cycle is the different stages the phases and activities over which a software evolves from the initial customer request to a fully developed software and we saw some of these activities in the previous lecture right so we start the development by gathering requirements which should cater to the need of the clients then we come up with a design which is a big picture view of the system then developers write code based on the requirements and the design and then we do testing and maintenance and this process is commonly known as the waterfall model or the plan and document perspective it is known as waterfall model because each of these phases occur one after the other and it is known as a plan and document perspective because before we start writing code we have to come up with a plan for the project which includes extensive detailed documentation of all the phases of that plan and progress is then measured against this plan so learners let's reflect on this question so we saw that in the waterfall model each of these phases follow one after the other so what could go wrong if we follow these phases sequentially please pause this video and think about some reasons before proceeding okay so now let's look at some of the drawbacks of the waterfall model let's say we are developing a software for a client and we talk to the client we gather requirements let's say that takes around two months then based on these requirements we come up with the big picture view the design right that takes around three months then after that we start writing code for this design that takes around four months and we test and fix bugs which takes another three months so from the time of gathering requirements till the testing phase and finally the release it takes around 12 months it takes one year to develop the entire system and we release it to the clients but unfortunately the client says that he or she doesn't like it there has been some misunderstanding regarding what the requirements are regarding certain aspects of the requirements or maybe the client changed his own mind about certain aspects of some requirements maybe they don't like the user interface right so these are some drawbacks and because of this now i have to go back and refine my requirements and start this process again so what are the drawbacks of the waterfall model one as we saw so there is an increase in cost and time if changes are required later on as we saw in this scenario second clients themselves may not know what they need so they might need to see something before they even realize what they actually need and third even the developers of the designers they might not know which design might be the most feasible or most usable by the clients and finally as we saw one phase or one iteration can take maybe six to even 18 months for one cycle to occur so these are certain drawbacks of the waterfall model so now as we have seen there are certain drawbacks of the waterfall model how can we address these issues or these disadvantages of the waterfall model can you think of some solutions please pause this video and think about some solutions before proceeding so one solution can be can we get feedback from the customers earlier on right so in this model which is known as the prototype model we build a working prototype of the system before development of the actual software and this prototype has limited functional capabilities and their performance might not be optimal compared to the actual software the advantage is that it's easier for the customers to understand what they want once they see this prototype as well as for developers and engineers to understand how to build it better once they have done it for the first time and usually the prototype it is not used later it is thrown away or new software is built so what are the advantages of the the prototype model so one it is useful when the exact form of the solution is not known and even the technical issues are unclear it is good to build a prototype and as we saw it is useful to get feedback from customers however what is the disadvantage one is that it can increase the cost of development for projects because as we saw the prototypes are not usually used later on and since we are not building the actual system so what about risks and bugs which appear later in the software development in the development cycle so the prototype model cannot capture these another solution can be to incrementally build the software right get feedback refine and this model is known as the spiral model so the spiral model it combines both the waterfall and the prototyping model and as you can see in this image there are four phases first we determine the objectives alternatives constraints for this one iteration and then we evaluate alternatives we resolve risk and then we develop and test and release the product to the client and then we plan for the next phase so at each iteration there was a refinement of the prototype compared to the previous version and unlike the waterfall model where we document everything at the beginning the requirement documents are developed across each iteration as and when they are needed and the software eventually evolves into the final product and we also involve customers at the end of every iteration and this helps in reducing misunderstandings between the client and the developers but one drawback of this model is that the iterations still take long time so it takes around 6 to 24 months for each iteration so to summarize in this video we looked at the software development life cycle which is the different activities that need to be carried out for this for software development we looked at different models in this plan and document perspective we looked at the waterfall model where each of the phases are followed sequentially then we looked at the prototype model where we build a prototype first and get feedback from users and the spiral model which combines the advantages of waterfall and the prototype model now in the next video we will be looking at the agile perspective which is a quite popular perspective nowadays to develop software and we will be using many of the principles from the agile perspective throughout the course"],
        7: ['https://youtu.be/nQzRUGuEDXs',
        "in the previous videos we looked at the software development lifecycle particularly the waterfall model and its extensions and these models are known as the plan and document process models wherein you come up with a plan for the project which includes extensive and detailed documentation of all the phases of that plan and progress of software development is measured against this plan we saw different models like the waterfall model the prototype model the spiral model etc and although these plan and document processes they brought discipline to software development they were not very effective in terms of on-time delivery and being within the specified budget so let's look at some examples so the set of images on the screen it shows the status of software projects across different years from 1995 to 2013. and what these series of studies show is that 80 to 90 percent of all software projects are either late or over budget or simply just abandoned and this is a shocking number right so on the other hand it's just 10 to 15 percent of software projects which are on time and on budget so this was considered a severe drawback of the plan and document perspective so to address these problems or these difficulties around 20 years ago in february 2001 a group of software developers they met to develop a lighter weight software development lifecycle and this came to be known as the agile manifesto so this manifesto the agile manifesto is built on four key principles one it emphasizes individuals and interactions over processes and tools so although processes and tools are important it emphasizes interactions between individuals in the development team as well as with the clients second rather than focusing a lot on comprehensive and extensive documentation the emphasis is on delivering working software and this is delivered in increments and the agile manifesto emphasizes a lot on collaboration with the customer to actually understand the exact needs of the customer rather than negotiating over contract details and finally instead of following a strict and rigorous plan agile emphasizes on responding to change whenever it is required and what the manifesto states is that although the items on the right are valuable the items on the left are more valuable in the agile development process this agile process is being widely used today and in this approach software projects are built using multiple iterations and thus it is known as an iterative software development model or incremental software development where the teams work together to deliver the product in small increments so instead of waiting till the end to deliver the entire product teams they develop prototypes of key features and quickly release the prototype for feedback for example in the first iteration the development team might build features for key requirements they then show it to the client and get their feedback so even if the client wants changes the team can quickly refine it in the next iteration okay so let us look at some agile approaches so one of the earliest agile approaches is extreme programming or xp and it has several key practices like behavior driven design test driven development pair programming etc we will look at some of these in detail in the upcoming weeks another approach is known as scrum in which the product is built in the series of iterations known as prints which are roughly one to two weeks long and if this helps break down a big complex project into several small bite-size pieces another approach is known as kanban where the software to be built is again divided into small work items and these are represented on a kanban board allowing team members to see the state of every piece of work at any given time so in this course we will be following several practices from extreme programming and scrum such as behavior driven design test driven development sprints and all for our group projects so the important thing to note here is that rather than just following these approaches and practices the agile development is more of adhering to the broad philosophy and the principles outlined by the agile process so when you approach software development in this manner it is generally good to live by these values and principles and use them to help figure out the right things to do given your particular context so now that we have seen these two broad perspectives the plan and document perspective and the agile perspective let's reflect on this question when should we use the plan and document perspective and when should we use the agile perspective so let's say we want to build a software product which process should i use what are certain factors or characteristics which will help you determine which model to use so please pause this video and think about your responses before proceeding so which process model to use depends on several factors and this set of questions can help us get a better idea of which model to use so a no answer to most of these questions suggests agile whereas if it's a yes to most of these questions then a plan and document perspective might be better so let's look at these questions so firstly if the requirements are the specifications if they are required to be fixed up front at the start of the project then a plan and document perspective might be better and it also depends on the clients or the customers if they are unavailable for most of the time then maybe a plan and document perspective might be better and a decision also depends on the characteristics of the system to be built right so if the system to be built is large if it is very complex so for example you have to build software for maybe an air missile system or a nuclear power plant right there is no margin for error and hence extensive planning and documentation is a necessity in such cases so it might be better to go for a plan and document process characteristics is about the team your software uh team so if they are geographically distributed uh if the team already is familiar with the document or documentation model then it might be better to use a plan and document process and finally is the system which we have to build is it subject to several regulations for example if you want to build a banking software you need approvals from banks from the government etc hence upfront planning and documentation is necessary so the key thing to remember here is that the type of approach you follow it depends on a lot of factors right it depends on the clients the characteristics of the system and the team so once you start working in a software company different teams and different organizations will use different processes based on the characteristics of the client the system to be built as well as the team"],
    },
    2: {    
        1: ['https://youtu.be/6cjKDEoCvMc',
        "in the previous week we looked at the software development process and we saw various models like the waterfall model and agile model in this week we will be looking at the first step in software engineering basically identifying requirements for a software solution this is a very important step because we need to spend sufficient time and effort in identifying such requirements and documenting why because if we do not do this thoroughly there will be a mismatch between what the user expects and what the software developer does so this week we will focus on requirements ok so you might not be so convinced that identifying requirements are important and you might also think why we need to spend so much time and effort in identifying as well as documenting these requirements can't we just identify the requirements as we go about designing and developing the software system so let's reflect on this question so learners what are the disadvantages if we do not spend time and effort in identifying and documenting requirements you can pause this video and write down your responses before proceeding our vision of what the software should look like and behave is quite different from what the user has in mind even historically many projects have had this problem developers started to implement something while the users actually were expecting something else so there was a mismatch of expectations now what is the cost involved here you've spent a lot of time effort and money in developing something which was not what your customer asked for so so you have to make changes so there are more iterations in the software development process and this pushes up the development cost very significantly so to summarize the importance of requirement identification and analysis are twofold one is that we understand developers understand what the customers want of how the software should look and behave and two the customers agree that the developers are understanding is along the lines of what they are expecting otherwise the cost the time the effort involved in developing the software can increase significantly so now that we have established that requirements are important how do we go about it here the first thing i need to know is what does my customer want from the system again remember the customer is not always the end user the customer can be an internal user customer could be somebody from a different team so i need to ask the customers what do they want and then i look at what they want analyze them in order to plan how do i develop my piece of the software all of this may sound fairly abstract at this point and we will look at an example later but the point to keep in mind here is that first teams gather requirements then they analyze them and only after that they think about how to develop the software let us start with requirement gathering that seems very straight forward right just go ask clients what they want and we get a bunch of requirements in reality it is not that simple first of all there are different kinds of people who are going to be your customers in the system all these users are called stakeholders of the system so when you introduce a software system it influences different types of users they may belong to your own organization other organizations or end users and they may have different roles and profiles so what is required is to be able to understand the requirements of all these users in a broad holistic manner before diving into designing the software let us look at this with an example so let us take an example from amazon itself and let's say amazon wants to develop a portal for people who want to sell their products online the products which sellers list on the portal will be available for people to buy on amazon so let's think about the frequent users of this seller port and these users are known as the primary users of our system so who do you think are primary users of this amazon seller portal well they can be the independent sellers who sell specific products primary users can also be the sales team of consumer companies like those who sell electronics like mobiles computers etc even independent authors and publishers who want to sell their books online can be the primary users of this seller portal system then there are other types of users who are known as the secondary users and these users they do not directly use the system but use the system through an intermediary so can you think of some secondary users of this seller portal so earlier we mentioned that the sales team they can be primary users and such sales teams usually have managers who periodically want to check the sales numbers the profits and margins etcetera so the sales managers can be the secondary users of this amazon seller put and then there are users who do not use the software but are affected by the introduction of the software or they even influence the purchase of the software so these users are known as the tertiary users of the system so learners can you think of tertiary users of this amazon seller portal who do you think are users who do not use the system at all but are affected by it in some way you can pause this video and write down your responses before proceeding so who are the tertiary users well logistics shipping companies they are responsible for delivering items to buyers so they are potential tertiary users of the system another type of tertiary users can be banks so the portal has to interface with banks to ensure that timely transfer of money happens to buyers based on the sale of their products what about people who buy on amazon even they are tertiary users right they're buying depends on what products sellers sell on the portal so all of these users are possible tertiary users of the system we saw that there are different uses of the system and we have to seek requirements from these users so how do we go about it do we randomly tap a few users and ask them or do we conduct systematic interviews there are many ways of doing this in many cases a basic interview might be sufficient but there are also ways like studying existing documentation having focus groups of different categories of users and also by observing what users are doing with the system or what do they need we learn about all this in the next video so now let's say we have gathered these requirements and now the next step is to analyze them so how do we go about doing that so during requirement analysis one analyzes the gathered requirements to form a clear understanding of the exact customer requirements and to weed out any problems in the gathered requirements and these problems can arise because we will be gathering requirements from various stakeholders and from different sources so let's take the example of the amazon seller portal which we discussed earlier let's say we got a bunch of requirements from different clients different stakeholders so now what kind of problems or issues can arise from the requirements gathered let's reflect on this question for a moment so what kind of problems or issues can arise from the requirements gathered pause this video and write down your responses before proceeding one issue can be that requirements are not clear they might be ambiguous now what does this mean for example the requirement of independent sellers may be that they need to manage their inventory ok but this is ambiguous because what does manage really mean it depends on how you interpret it i may interpret manage as being able to add one more product you may interpret manage as being able to modify the price of a product or some other feature of the product somebody else may interpret manage as in a third way say delete some products add some new products and so on so the point is that there are several interpretations possible and developers will build a feature based on their own requirement so what we have to ensure is that the idea of what is required is the same both from the users perspective and the developers perspective another issue can be that the requirements are inconsistent or sometimes contradicting each other for example if you think of the amazon portal it may be that independent sellers may want their payment credited every week on the other hand a banking system may say that the payment can be credited only bi-weekly so these two requirements may actually conflict with each other while building the system so as developers we need to resolve these requirements in one way or the other for example you might say that for independent sellers we might tell them that this is all that can be provided as a feature once people know what the constraints are then you can go ahead with building the software a third issue could be that requirements are incomplete what does that mean it means that some aspects of the implementation may have been overlooked simply because neither the customer nor the developer were able to imagine the all the details of the system before beginning to develop it right for example independent sellers may mention that they want to be able to track orders now what does track orders mean does it mean that you want to track which orders are delivered or does it mean that you want to track the order while it's in transit or does it mean that you want to keep track of what orders have been returned etc so which type of orders does the seller want to track is an important information that the developer needs before being able to proceed to summarize in this video we have seen the importance of requirement identification and analysis identifying requirement by considering primary secondary and tertiary users of the system analysis of requirement is essentially to identify anomalies inconsistencies and incompleteness among the requirements once we have done this we are in a better position to start designing the system"],
        2: ['https://youtu.be/L9-CUa0BlLk',
        "we looked at requirement Gathering and Analysis and we also looked at how we need to consider the primary secondary and tertiary users of a system now that we have identified these different types of users the question is now how do we gather or identify requirements from these users do we just talk to users or are there other ways to gather these requirements so let's reflect on this question for a moment and let's take the example of the Amazon Seller portal that we looked at in the previous video let's say that it's the early days of Amazon and you have been commissioned by Amazon to build this Amazon Seller portal so here are some of the users that we identified in the previous lectures so we have independent sellers we have a sales team or a sales manager of different companies we we have people from the advertising Department we have Logistics or shipping company managers of course we have buyers and we have Banks so the these are different users of the system so now the question is what are ways in which we can gather requirements from these different users for developing a seller port you can pause this video and think about these answers before proceeding so there are different requirement collection techniques and let's look at them one by one so one type of requirement collection technique is what is known as a questionnaire so questionnaire is nothing but a series of questions which are designed to elicit specific information from users and I'm sure most of you would be familiar with questionnaires as you would have filled such question as as part of you know different courses and the program as well and these questions can be of different types can be a simple yes or no question maybe you have to choose from a set of answers or it can be a longer response or a comment and questionnaires are good for getting answers to specific questions from a large group of people who are usually spread across a wide geographical area so for example you can send questionnaires to sales team managers of several mobile companies and you can ask them questions like you know what percentage of your inventory do you sell online or you know what are main difficulties you encounter in selling your product online so these answers to these specific questions can help us elicit requirements from different users and an important thing to note is that this should be used in conjunction with other techniques other requirement Gathering techniques which we'll see in the next slide so another important requirement Gathering technique is interviews right and interviews it involves asking someone a set of questions it is often face to face but it need not be we can use telephonic interviews or even online interviews to ask questions and interviews are broadly classified as structured unstructured or semi-structured interviews depending on how rigorously the interviewer sticks to a prepared set of questions so an interview can be structured which is nothing but a fixed set of questions and the interviewer asks those questions and elicit responses and in an in an unstructured interview the interviewer doesn't really know what type of questions to ask because they don't know what the user does or what exactly their needs are so in such cases we can ask users broad questions and based on their responses we can probe further into specific aspects so what are purposes of these interviews one is we it helps us get or understand issues which people have and it can be used early in the requirement Gathering process to elicit different scenarios so for example we can conduct interviews with independent Sellers and ask them you know what are different platforms which you use to sell your products this is a fairly open-ended question and they might give answers like we use WhatsApp Instagram and then we can probe them and ask you know what are disadvantages or advantages of these portals and they might say well I get customers you know it's easy to get customers but then tracking orders you know tracking payments tracking my inventory what are different selling options all of this is a huge overhead right so from from these questions we can elicit requirements which involve tracking orders you know tracking payments and all of these things so now we looked at interviews and one drawback of interviews is that it offers only one perspective and an alternative can be to get a group of stakeholders to discuss issues and requirements and the the advantages of using focus groups are one is it helps us gain consensus so if different groups of stakeholders if they highlight the same issue or the same concern then we know that this is a key requirement which we need to build into our system and this is also useful for highlighting areas of conflict or disagreement so different groups of people might not agree and this helps us get a nuanced understanding of the needs of different stakeholders so let's take an example from the Amazon Seller portal itself so we can conduct focus groups with you know different sales team Managers from different verticals and there might be different expectations from different Industries so for example a mobile sales team might be very interested in understanding what is the sales summary at the launch of a particular mobile whereas departments like furniture they might be more interested in the sales summary of the last 30 days so from such focus groups we can elicit requirements like such as the summary of the sales in the past X days or in a specific day so these are some requirements which can be elicited from focus groups so in the previous requirement Gathering techniques we looked at interviews focus groups in these techniques we are asking people questions but one thing to remember is that what people say is often different from what they do and it is very difficult for humans to actually explain what they do or describe accurately how they do a particular task so for example how do buyers buy online what are they looking for in a product this might not be very easy to articulate and hence an important technique which we can use is observe users right it involves spending time with stakeholders as they go about doing their day-to-day tasks and observing their work in their natural setting and this involves you know shadowing a stakeholder making notes occasionally asking them questions but primarily observing what they do so let's take the example of a seller the seller portal so one way in which we can gather requirements is to look at how people sell in physical shops so for example shopkeepers or customers they give recommendations the customer might ask the shopkeeper for a new product and or the shopkeeper might ask the customer to try a new product customer feedback is also very important the shop owner they appreciate feedback about a product which they sold to their custom so these can be translated into the online setting as well in the form of recommendations as well as getting timely customer feedback another type of requirement Gathering technique is documentation so there are places where you know which helps several procedures and rules for doing a particular task and these might be written down in manuals or documents or there might be steps which are involved in performing in an activity or there might be regulations which might be governing a task so in our case in case of a seller portal Bank regulations are an important requirement to consider so for example how can you add sellers bank accounts to your portal or how frequently can you deposit money to seller accounts what are practices of other online marketplaces all these can be gathered from different documents or different procedures and regulations so here's a summary of the requirement Gathering techniques which we saw till now so we looked at question as interviews focus groups observations and documentations and each of them serve a specific purpose for example questionnaires are good for answering specific questions and interviews are good for exploring issues and for which we do not really have the answers for focus groups are important for collecting multiple viewpoints and observations are good for understanding the context in which a user performs a particular task and then we looked at documentation which involves procedures regulations and standards so we looked at several requirement Gathering techniques and using thought experiments on how we can gather requirements we were able to identify several requirements for the Amazon seller put for example we understood that a catalog and inventory are necessary and it is essential for us to track different things like orders payments the sales as well as customer feedback so to conclude let us look at some basic requirement Gathering guidelines so first we need to focus on identifying stakeholders needs and we need to involve all the stakeholder groups the primary secondary as well as the tertiary users because each of these types of users have different needs and requirements and it is advisable to use a combination of different requirement Gathering techniques mainly because different techniques have different purposes and we need to use them according to our needs another important point to consider is to run a pilot session if possible to ensure that your data Gathering session is likely to go as planned many a times especially for questionnaires you might miss out on a particular question you might have wrong options might be having missing options so it is difficult to go back and ask users to fill the survey again and hence it's important to test your Gathering techniques before you actually go about and gather requirements and finally data Gathering is expensive and it is time consuming because you have to talk to different types of users and once you get their responses you need to analyze them and all of this is a time consuming and effort consuming activity and hence often at times we have to be pragmatic and we have to make certain complexes"],
        3: ['https://youtu.be/CKGjkKXpCsw',
        "so in the previous lecture we looked at how we can gather and analyze requirements and we categorize these requirements into two broad categories of functional and non-functional requirements now another important point to consider is how we organize all these requirements that we have gathered and analyzed so in this and the upcoming lectures we will look at means by which we can effectively organize these requirements in the first week we looked at two prominent software process models the plan and the document model and the agile model and recall that in the plan and document model significant time is spent in planning and documenting the entire software process and in the plan and document perspective requirement gathering and analysis is usually done by a person known as a system analyst in consultation with other members of the software team and after the analyst has gathered all the required information regarding the software to be developed he or she starts to organize these requirements in what is known as a software requirements specification or an srs document and this document contains all the user requirements in a structured form so now let us look at the standard format of an srs document so this is the standard structure of an srs document so it has a table of contents which has several sections and subsections now let us look at some of the important sections in the srs document now section 1 and 2 it describes the broad outline and description of the software system which we want to build for example it contains the purpose the scope several definitions acronyms and abbreviations which will be used in the software as well as the perspective functions constraints assumptions dependencies and so on now section 3 of the srs document contains the specific functional as well as non-functional requirements of the system now let us look at section 3.1 section 3.1 refers to the external interface requirements and here we specify things like what are the user interfaces for example what are the sample screen images gui standards screen layout etc then we have hardware interfaces that is the interface between the hardware and the software such as the description of supported device types the nature of data and control interactions between the software and the hardware for example in an atm system we need to specify the interface between the atm hardware the atm card and the atm software next is descriptions about the software interface which is the connection between this software and other software components for example the database what is the operating system what are other tools and libraries which will be used and so on so for example in the amazon seller portal example which we described in the previous lectures so the seller portal has to interface with the amazon buying portal database so this is an important software interface which we have to specify then we have communication interfaces which are any communication which is required by the software example sending an email or sms notification about orders in the seller portal so that requires us to interface with an email server and such communication interfaces have to be specified now when we look at section 3.2 it outlines a broad high level function which is known as a system feature and the corresponding functional requirements for each of these system features so for example taking the example of the amazon seller portal we identified several key requirements such as managing the catalog the inventory tracking orders payments inventory and all of those things so all of this forms specific system features which can be listed in the system features section and for each of these system features we add additional functional requirements and finally section 3.3 to 3.6 contains details of non-functional requirements like performance security etc so one thing to remember is that this is a guideline of how an srs should be organized and it is generally not very rigid based on the organization and the context you are in modifications to the structure and the content are possible so now that we have seen what an srs document contains let's reflect on why maintaining such an srs document is important so what do you think are some advantages of maintaining such an srs document please pause this video and write down your responses before proceeding okay so let's look at some advantages of using an srs first it helps to form an agreement between the customers and developers so after the srs is prepared the srs document is also given to customers the customers read it and after several iterations finally the srs document is accepted so this helps the customers to form an expectation of what they will get from the developers and for the developers about what the customer expects from the software second it helps to reduce future reworks an srs forces stakeholders to rigorously think about all the requirements before the start of the design and development and this helps to reduce changes in later stages third an srs provides a basis for estimating costs and schedules so in subsequent weeks we will look at important tasks in managing a software project so estimating cost and schedule is an important software management task and an srs helps in estimating the size of the software which is nothing but a function of all the requirements of the system and based on this estimation other estimations such as effort required and cost are estimated and based on these estimates the project manager can also create a schedule for the development of the software and finally an srs can facilitate future extensions and it can serve as a basis for planning future enhancements of the software system so in this lecture we looked at what a software requirement specification document is we looked at different parts and benefits of the nsrs however there is a drawback of srs which is a lot of documentation is required and this is okay if the requirements are fixed in the next lecture we will look at the agile perspective which is the behavior driven design which can help in addressing this drawback of srs in the plan and document perspective you"],
        4: ['https://youtu.be/Ml0HET0Va_c',
        "in the previous videos we looked at the requirement phase in the plan and document perspective how a software team can gather and analyze requirements and how they can organize this information in a document known as the srs or the software requirements specification document we saw that the srs document serves as an agreement between the customers and developers however in many projects customers themselves are unsure of the requirements and their understanding of their needs evolve and can change over time so how can we address this issue the agile perspective can address some of these problems so in week one we saw that the agile process involves working closely and interacting frequently with stakeholders to develop and refine requirements it also involves building a working prototype and refining it by adding new features in sprints or iterations and these iterations run typically every two weeks so in the agile perspective we are basically in the maintenance mode as soon as we come up with some requirements and then we start implementing features which match these requirements so this agile life cycle begins with what is known as behavior driven design so let us look at what behavior driven design is behavior-driven design or bdd it asks questions about the behavior of an application before as well as during development so that stakeholders are less likely to miscommunicate so even in this case requirements are written down but these requirements are continuously refined to meet the stakeholders requirements and expectations the bdd version of requirements are known as user stories and user stories take the place of what srs was in the plan and document perspective now let's look at what user stories are so user stories are short informal plain language description of what a user wants to do within a software product which is beneficial and of value for them so user stories come from the human computer interaction community or the hci community and these user stories are developed in three inch by five inch or three by five index cards so we write these user stories in small cards and user stories are the smallest unit of work which can be done in one sprint and one sprint is roughly one to two weeks and user stories follow a particular pattern or template which is known as the role feature benefit pattern which states that as a particular type of user i want a particular action so that this that provides a particular value or benefit to the use so let's look at some examples so let's take the example from the seller portal problem that we discussed in the previous lectures here is a requirement that we gathered from several stakeholders about viewing an inventory so user story for this is shown here so the feature is view inventory so as an independent seller which is a type of user i want to view my inventory which is an action so that i receive a particular benefit that is i can take stock of the products which are low in number let's take another example of tracking customer feedback so what will a user story for this look like so here again we follow the same pattern as an independent seller which is the type of user i want to view my customers feedback for each product and so that i can get a sense of the pertinent issues in my products so this is the value which we are providing to the user so what are some benefits of these user stories one we saw that they are lightweight versions of the requirements as opposed to the srs documentation which we saw earlier second user stories help stakeholders plan and prioritize development so for example if i want a feature which has to be implemented first maybe for to get immediate feedback or to get a feel of the system i can prioritize the development of the user story corresponding to that feature so for example we have two features of viewing inventory and tracking customer feedback in this case the client might want to implement the catalog and the inventory first so the development team can tell the customers that we will provide the view inventory feature in two weeks so if you have noticed we have not told the customers how we will implement these features so by concentrating on the behavior versus the implementation of the application it is easier to reduce misunderstanding between stakeholders another benefit is that it facilitates conversations between the users and the development team so more than creating user stories it is this conversation this back and forth between the different perspectives of each participant that will bring better simpler and more valuable solutions to users problems for example let's take this feature of tracking customer feedback so when we show this to a client the customer or the client will realize that maybe i would also like to be notified by email about the products which have low ratings of one or two stars and such modifications are common in the agile perspective and user stories can facilitate such modifications so what are some guidelines to create good user stories the acronym smart can help us come up with good user stories smart user stories are specific they are measurable achievable relevant and time boxed so let us look at each of these in detail first user story should be specimen specific so specific user stories are essential so that we know exactly what to implement so let's consider this user story which states that users can search for a product in the catalog so this is a bit way because we have not exactly specified for example what type of product it is or based on what attribute can be searched for a product a more specific user story can be that the user can search for a product by title in the catalog next user story should be measurable so each story should be testable which implies that there are non-expected results for some good inputs so let's take this feature the seller portal should have good response time so what do we mean by good this is vague and it is not easily measurable a more measurable user story can be so when adding a product to the catalog the product should appear in the catalog within three seconds and this is measurable and this is testable so make sure that your user stories are measurable next user story should be achievable ideally we should be able to implement a user story in one agile iteration that is in one to two weeks and if you are not able to complete one story per iteration then they are too big and you need to subdivide these stories into smaller ones so for example view inventory might not be able we might not be able to implement this in one week or in one iteration hence we can divide it into two or three features where feature 1a is we implement the feature of viewing all products in the inventory in a single page and then we add pagination and maybe filters can be the next feature so in this way we make sure that one user story is completed in one agile iteration next user story should be relevant so user story must have some business value to one or more stakeholders so how can we be sure that a user story is relevant we should ask questions we should ask questions like why is this feature needed is it really important is it adding any value so what if this feature is added so these questions can help us and ensure that the user stories which we add are relevant next user story should be time boxed so time box still means that we should stop implementing a feature once we have exceeded the time budget so what should we do if we have exceeded the time budget one is we either give up or as we saw earlier we divide the story into smaller ones and or we reschedule what is left according to a new estimate we revise our estimates so it is important to make sure that you are on schedule so we have seen the benefits of user stories but let's reflect on this question for a moment on what are certain drawbacks of user stories are they always good can they not be used in certain situations please pause this video and write down your responses before proceeding so what are certain drawbacks of user stories one it may be difficult or too expensive to have continuous contact with customers throughout the development process because customers may not want to participate or they may not be available at all times second this approach may also not scale to very large software development projects or even safety critical applications because in such projects extensive planning and documentation is required before the actual implementation and especially for safety critical applications there is no room for errors or refinement so the key point to remember is that software development methodologies depend on the type of application you are building so in this lecture we looked at behavior driven development of bdd so bdd asks questions about the behavior of an application before and during development so that the stakeholders are less likely to miscommunicate we saw that the bdd version of requirements is user stories we saw the role feature benefit pattern or template we looked at the characteristics of good user stories that is smart user stories that it should be specific measurable achievable relevant and time boxed and we also looked at the benefits and drawbacks of user stories"],
        5: ['https://youtu.be/_KH9dSFVYTs',
        "the previous week we looked at how we can gather and analyze requirements and we also looked at how we can create user stories which can help us understand what different users want to do within a software product which is of value to them and if you have noticed most of the user stories require you to create a user interface or a UI which implements that feature and this interface acts as the interaction point between the user and the system so the next step is to create such user interfaces like web pages which contain elements like buttons text field navigation Etc which realize these user stories and requirements and although this seems very straightforward there are principles and guidelines to create effective user interfaces and that will be the focus for this week and all of us interact with hundreds of such interfaces every day the apps that we use the websites we browse the software programs we work with and even physical objects in our day-to-day lives so ordinary objects that we use every day have undergone several rounds of discussion and deliberation to come up with the final design and this picture is shows how much discussions and deliberations are needed to come up with an effective user interface now let's discuss about websites and you know mobile app interfaces do we need to place so much emphasis about what is shown where it's shown how it can be accessed and so on if you think about it the form of your product is what the user sees first and then only comes the functionality of your product so if the form of the product or the interface as they say if that is not appealing enough or intuitive enough then its either going to be rejected by the users or they are going to find it extremely cumbersome to use so the key idea here is to give the user a good experience while using your software so the software should be easy to use it should be easy to learn it should not be confusing and so on we will learn about all this in the upcoming videos there are certain guidelines we should follow to design these websites and apps okay so now let us think about the different websites that you have been to some which have been excellent and some which you have really not liked and think about what are these experiences that frustrate a user will pause here can write a few of your ideas and then proceed so here's an example of a website and I'm sure if you go to it it will leave you frustrated right so looking at this image you can see that the layout is cluttered there is no hierarchy there is no navigation you know the typography is very poor there is random use of colors so all of these are things which can frustrate users of course this is a very extreme example not all websites are like this in addition to this other factors such as slow load time there are too many ads if the color scheme is inconsistent these can also frustrate users so we now understood that we need to take care of Designing the UI as well in software companies there are specific job profiles which look at the user interface aspects so companies have specific roles such as interaction designers user experience and user interface Developers that look at these aspects and this broad field of Designing effective user interfaces is known as interaction design by interaction design we mean designing interactive products to support people in their everyday working lives to summarize the activities involved in interaction design are identify the needs and requirements developing alternative designs that meet those requirements build interactive versions and evaluate which of these designs are actually useful usable for the user now this looks very similar to the agile process that we talked about earlier there are a lot of similarities the reason is that both of these keep the user at the center or at the focus of creating the product going on we also talked about Gathering of requirements analysis of requirements from the various stakeholders now that we have done that the next step for us is to develop alternate designs that can satisfy these requirements then evaluate them before we jump into implementing the software now how do we go about developing these alternate designs there are various techniques such as storyboarding paper prototyping and so on in the next videos we will see some of these techniques and we will also do some Hands-On activities along these lines"],
    },   
    3: {     
        1: ['https://youtu.be/BOCF3RefE54',
        "in the previous led we looked at the importance of designing good user interfaces the user interface should realize the requirements provided by the user but it is also important that the interface is usable in this video we will be looking at what are certain goals and principles required to design usable interfaces so what does usability mean usability is an iso standard and it is defined as the extent to which a product can be used by specified users to achieve specified goals and the following are the key usability goals such as effectiveness efficiency safe to use learnability and memorability we will look at each one in detail the first usability goal is effectiveness and this is a general goal which describes how good a system is at doing what it is supposed to do so is the system capable of let's say allowing people to learn well if it's a learning system or helps people carry out their work efficiently access the information they need buy the goods they want etc and such effective systems are there all around us so let's look at some examples a common example of an effective user interface is google and i'm sure all of you have used google multiple times each day google has a minimal design and the and if you notice the main functionality which is the search is at the center amazon also has a very effective ui so all the necessary information is on a single page such as the cost when i get it get the product offers all of this is on a single page and there is no need to scroll as well now let's look at efficiency so efficiency is the way a system supports users in carrying out the tasks it lets users carry out common tasks through a minimal number of steps and let's say users have learned how to use a system can they sustain a high level of productivity using the system efficient user interfaces helps users do that for example let's say we want to buy a product at amazon so how many clicks are required to buy an item at amazon so you click on buy now first then you select a delivery address then you select the payment method and then finally you can buy that and if you notice amazon avoids repetitive tasks such as it helps us save the delivery address save the card details so that users users who come again and again can buy an item quickly the next usability goal is safety so there are two aspects to safety the first aspect is protecting the user from dangerous conditions and undesirable situations for example the user interfaces of x-ray machines chemical plants they should be safe for example therap-25 was a radiation therapy machine it was the first of its kind which had a dual treatment mode and it used software based safety systems rather than hardware controls however one day while treating a patient the operator pressed x for the x-ray mode instead of e for the electron mode and this led to excess radiation and the death of a patient however most of us won't be using or designing such safety critical systems and the second aspect of safety is helping users in any situation to avoid carrying out actions accident so these unwanted actions can be we press wrong keys by mistake or if we have made some errors we should provide means of recovery to users so let's reflect on this question so most of you have used several software applications so recall certain software applications that you use and are there ways in which these applications have helped you reduce the risk of wrong keys being pressed or it provided a means of recovery if you made errors please pause this video and write down your responses before proceed so the second aspect of safety is helping users in any situation to avoid carrying out unwanted actions so think about software applications which have reduced the risk of wrong keys being pressed most common example is when you use document systems if you notice the save button and the close button are far apart right and if we look at if let's say this we have made certain errors there are several applications which provide a means of recovery as well examples of this are let's say you accidentally deleted a file on windows or any operating system you can easily recover it from the trash let's say you are editing a document in word and the computer accidentally shut down when you open word the next time you are provided with recovery options control z or undo is a common feature in most office software and even in whatsapp if you send a message by mistake you can always delete the message the next usability goal is learnability learnability refers to how easy a system is to learn to use people usually don't like spending a long time learning how to use a system they want to get started right away and carry out tasks without much effort so common applications like facebook instagram whatsapp so did you read a manual to use these systems no right you learned on the go as you started using these systems so these are fine for simple systems but what about complex systems where you have to perform complex tasks so let's reflect on this for a moment so what are ways in which you can help users learn how to use a complex system please pause the video and write down your responses before proceed so there are several ways in which you can make your system more learnable one way is to use wizards wizards are a step-by-step process of achieving a task it breaks down a complex task into simpler tasks another way is to use a tool so tools on the web page can be used where there are lots of information of features on a single web page and the tool highlights important areas or features of the page for new learners next is templates so templates provide defaults or structure based on the specific type of task so let's say you want to make a resume the resume template can help you do or create resumes fast so in these cases you don't have to start from scratch but can use a template and start using the system another important usability goal is memorability memorability refers to how system how easy a system is to remember how to use once learned this is especially important for interactive systems that are used infrequently so let's say if users haven't used a system for a few months or even longer they should be able to remember how to use it so they shouldn't have to keep relearning how to carry out tasks a good example of memorables a memorable system is microsoft word so there are meaningful icons command names menu options all of these help users remember where to look to find a particular tool to a given stage of a task so the usability goals which we described earlier are central while designing interactive systems but apart from this based on the type of software we are building we also want to make the user experience positive emotions while using the software so these can include making them making the user interface satisfying enjoyable fun helpful etc and these are known as user experience goals so they are more subjective and they are concerned with how users experience and interact with the product from their perspective rather than assessing how useful or productive a system is from its own perspective so these goals also have to be kept in mind while building interactive software products so this diagram provides a good summary of what we discussed in this led we looked at usability goals such as effectiveness efficiency safety learnability and memorability and then we also looked at user experience goals which are subjective positive experiences that the user should have while interacting with the software so the next time you use a system that you really enjoy try to think about which usability and user experience goals were satisfied by the user interface and i hope that these usability goals and user experience goals will be useful for you as you go about designing user interfaces for your projects"],
        2: ['https://youtu.be/I1s8WWUMGQs',
        "in the previous video we looked at goals and principles to design usable interfaces so usable interfaces refer to interfaces that are effective efficient learnable memorable and safe and they also ensure that users have positive experiences while using these interfaces so keeping these goals and principles in mind we can now start building interfaces which implement the user stories and requirements and also recall that the process of interaction design it involves first identifying the needs and requirements then we develop alternative designs that meet those requirements then we build interactive versions of these designs and finally we evaluate the user interface so now let's say we have identified the needs and requirements and we know what the goals are which we need to keep in mind while building such systems so now we can proceed to the second step of developing alternative designs and building interactive versions of the user interface but how do we do this can we directly jump and write code do you think that is a good idea so let's reflect on this question are we ready to code once we know the needs and the requirements can we code the ui right away what are some reasons for not doing so you can pause this video and think of some reasons before proceeding okay so what are some reasons for why we shouldn't start coding right away one is that the initial design ideas it might not be the best ones so users may not like certain aspects of the initial ui second developing a user interface writing code it takes time it takes money and effort and if the users do not like the first version then we have to go back and write code and redesign the entire user interface from scratch so the solution for this is to develop prototypes so prototypes allow you to quickly test on users get some feedback and iterate so prototypes it helps us answer questions and also support designers in choosing between different alternatives so what are the purposes of prototyping it helps us test out the technical feasibility of an idea so some aspects of the user interface might not be very clear at the start and also we might have some very vague requirements so once we build a simple prototype and show it to users then they might give us feedback and it will help us clarify these vague requirements as well and prototyping is also useful for user testing and evaluating our initial prototypes or initial user interfaces so prototypes help us to build something quickly and get feedback quickly cut so now let us look at different types of prototypes so we can develop different types of prototypes based on the purpose and the time of development and also the fidelity fidelity refers to how real the interface is compared to the final product so in this graph you can see that storyboards and paper prototypes they are developed initially and they do not resemble the final product that much but as you move towards the right top right you see that digital mockups and interactive prototypes move closer to the final product which we want to build so now let us look at what storyboards are so storyboard is nothing but a hand-drawn comic that features three important elements one is the setting second the sequence of activities in the task and finally the satisfaction which the user receives so setting refers to the context in which the system the software or the app will be used for example who all other people involved what is the environment what is the task which needs to be accomplished and the second aspect is the sequence so what steps are involved and what is the task and how is it being illustrated all that comes in the sequence and finally the satisfaction so what motivates people to use the system what sense of accomplishment do they get after using the system and what need does the system fill so this also has to be mentioned in the storyboard so let's take an example of a storyboard so we will be looking at an application known as speakup so speakup is a virtual reality tool which can be used to give effective presentations so let's say we want to give a presentation in front of a large audience so before we give the actual presentation we can use speakup which is a vr application that simulates a presentation setting for us we can record our audio and hints are provided and all of these features are present in this tool so let's see how we can create a storyboard for such a tool so now let's look at the storyboard for the speak up vr application so recall that the first step in storyboarding is to develop the setting right so who are the people involved what is the environment and what is the task which has to be accomplished here you can see that a person he has to give a presentation on monday and he is practicing in front of a mirror but on the day of the presentation he is nervous and he he's not able to give the presentation well right so we see who are the people involved what is the environment and what is the task the task is to give an effective presentation now that the setting has been established now the second step is the sequence or what are the steps or what is the task which the software system helps the user to do so here you see that a friend recommends speak up to this person and talks about what all are the features in speak up and here we see that the user starts using speak up so he can choose a type of audience and he can start recording his audio we see that the system gives feedback gives comments the user can send the recording of his presentation to his mentor and there is a second round of practice so in all of these we see that the steps which are involved are clearly defined what is a task all that has been clearly defined in the storyboard and finally we see that this person presents effectively in front of the in front of an audience and this brings us to the third part of storyboarding which is the satisfaction right what motivates people to use the system or what is the sense of accomplishment that this person receives after using the system so here we can see that this person becomes confident he can effectively give a presentation in front of a large audience now that we have seen an example of a storyboard let's look at what are its benefits one is that a storyboard gives us a holistic focus right it emphasizes how the interface accomplishes a task without giving specific details about it also it avoids commitment to a particular user interface so in the case of the speak up storyboard you might have noticed that no user interface or none of the features were actually developed and finally it helps develop a shared understanding among the different stakeholders so this ensures that all the stakeholders are on the same page in terms of the goals of the software system which we want to build so we looked at storyboards another type of prototypes is to use paper prototypes so paper prototypes are simple it is a hand drawn user interface and we usually use multiple pieces of paper to actually draw the ui of different screens so let's look at an example so this is an example of an online library system for the deaf and hard of hearing or the dhh and speech impaired students so it has several features such as you know books are provided in indian sign language there are options for speech therapy etc so let's look at how we can develop a paper prototype for this application so this is a prototype for an online library for dhh and speech impaired students so as we mentioned in the paper prototype the different screens of the ui or all the elements of the ui are drawn on a piece of paper so here you can see that the first screen which a user encounters is the login screen and when the user clicks on a particular link or button what is the next screen which appears that is being shown so for example a user can be a student teacher or a parent so the appropriate user can click on the particular button and then it proceeds to show the options for different screens so if i click on a particular option what is the next screen which appears that is being shown this process continues for all the screens in the application so for example here when i choose isl which stands for indian sign language then there is a drop down in which i can choose the language which i want to see it in and for each option what are the different screens which are visible to me that is being shown so let's look at some benefits of these paper prototypes one is that it is much easier than writing code for the actual user interface right developing these paper prototypes involve just drawing something on a piece of paper drawing the different screens and hence it's much easier than writing code and with paper prototypes you can start conversations about user interactions as we saw that it gives us a flow of how the screens will progress for different features and this can be used to talk to the client and see if both the client and the developers are on the same page and third these elements can be changed immediately on the fly right if the client wants some features or some buttons or some navigation to be changed these elements can be changed immediately based on the given feedback so that was about paper prototypes another type of prototype is to use digital mockups using tools such as photoshop powerpoint etc and these are more closer to the final product so let's look at the same example of what we saw in the paper prototypes and let's see how we can transform or translate this paper prototype into a digital mockup so we saw how we can develop paper prototypes and now once we have these paper prototypes it is not very difficult to translate them into digital mockups so you can use tools like powerpoint photoshop and another tool which can help you do this is known as figma so let's see how this the paper prototype has been translated into a digital mockup so here you can see that you can explore the library so there are buttons which are clickable and i can click on any link right if i want to read some ebooks for a particular subject right and here i can see that these are the options which are available you need not enable all the options right so in this way a digital mockup can create or help you develop interactions for different screens in your application and it moves you closer to the final product and once you have this digital mock-up ready you can show it to clients get feedback from them and this will help you transition or move towards the final software product so in this video we looked at several prototyping techniques and we saw that these prototyping techniques they differ based on when it is used in the development process and its fidelity compared to the final product or how real the product is compared to the final product and we looked at several techniques and the important thing to note is that these prototypes they facilitate conversations about different things with their clients among developers designers etc so for example the storyboard it facilitates conversations about the user tasks or the use goals of the software system which we want to build paper prototypes goes one step further where we design the screens the ui elements on paper and this helps us facilitate conversations about the actual interactions in the system whereas in digital mockups and in interactive prototypes you talk about the visual design or you talk about the final details of the user interface so in this way these different type of prototyping techniques can help us refine our user interface and develop effective and usable interfaces"],
        3: ['https://youtu.be/jQ_vO3xjFt0',
        "in the previous video we looked at various usability and user experience goals and how we can create prototypes we saw that prototypes help us quickly test on users get feedback i trade and it also helps facilitate conversations now let's say that we have created a user interface for our prototype based on the usability and user experience goals now how do we actually know that our ui is usable and effective so what are ways in which we can evaluate our ui so let's reflect on this question for a moment so what are ways in which you can evaluate the user interface of your prototype please pause the video and write down your responses before proceeding so there are several ways in which you can evaluate your ui so some of you would have thought of assessing it with real users so show the ui to your clients or to your end users make them use it ask for feedback another way can be to get critique from expert designers so show expert designers your ui and ask them for feedback but how do you think they will evaluate it well it can be subjective based on their experiences but it would also be helpful if we have a checklist or a set of more specific guidelines which will help us evaluate if our interfaces are effective efficient safe etc so this is where heuristics come in so heuristics are the strategies which are derived from previous experiences with similar problems over time designers come up with certain rules of thumb or guidelines based on their experiences and the most widely used set of design heuristics is by jacob nielsen who came up with a set of ten design heuristics so this image is taken from professor scott klemmer's hci course where he has grouped these heuristics into three broad categories of understanding action and feedback we will be looking at these heuristics in this and the upcoming videos so let's look at the consistency heuristic so consistency can be in terms of a consistent layout and the layout across all screens should be consistent in terms of color font etc so if you look at the windows of your operating system the placement of buttons such as the yes and no buttons the minimize restore close all of these are consistent across all windows a second aspect of consistency is that you should have consistent names throughout all screens in your product for example the name of product features etc should be the same throughout your application the next heuristic is using familiar metaphors and language so we should use words and phrases which are familiar to our end users and not use technical or jargon terms so one example is when you do online shopping so when you do online shopping platforms use terms which are used in physical stores example checkout shopping cart and these are terms which are familiar to users another example is when you pay online you use a mobile wallet and this is similar to actions which we do with a physical wallet like adding removing money etc the next heuristic in understanding is a clean and functional design so our application should have a clean and functional design which is minimal and easy to understand so if you look at this image so this is an extreme example of a very cluttered design there are multiple colors fonts images and there is no common theme and hence it is difficult to find relevant information so let's contrast this with another ui here you can see that there is a clear navigation on the left which describes the key features of the system the colors and fonts are consistent throughout the screen so in this video we looked at an effective way to evaluate a user interface design heuristics can provide us with guidelines to effectively evaluate a given design we looked at nielsen's design heuristics and looked at heuristics related to understanding"],
        4: ['https://youtu.be/Z975GdR1l40',
        "we looked at Nielsen's design heuristics and looked at heuristics related to understanding in this video we look at heuristics related to action let's look at the freedom heuristic so there are different aspects of the freedom heuristic one is the freedom to undo so we saw this in the previous videos as well so let's say we have deleted a file we can always recover it from trash and document editing softwares have recovery options and keyboard shortcuts like Ctrl Z2 undo another aspect of freedom is the freedom to explore so platform should provide freedom for users to explore the key features so for example in shop online shopping portals we are able to look at products without actually signing in these platforms give us the freedom to explore the products another example is of the IRCTC website 10 years ago so here we can see that the earlier IRCTC website did not allow users to search for trains without logging in hence it restricted users freedom to use key features of the application whereas now we can search for tickets without logging in foreign next heuristic is flexibility so experts as well as new users should be able to carry out tasks efficiently so new users often require guidance when using a system and need clear and obvious options so they usually rely heavily on step-by-step results or clearly labeled menus however more experienced users learn the required keyboard shortcuts to complete the same tasks let's look at example of document processing softwares like word Google Docs Etc so when a new user needs to edit a document they will initially go through various menus and click on the card copy and paste menu item and as they gain fluency and experience using this word processor they will start using shortcuts another aspect of flexibility is providing personalization this refers to tailoring content and functionality for individual users for example social media apps they provide posts and content based on your interests or your history flexibility also involves customization whereby allowing users to make selections about how they want the product to work an example of this is news apps which asks users to select which topics they want news about the next design heuristic is recognition over recall so users have limited memory and they are not able to recall some information however they find it easier to recognize something they have seen earlier so for example if I ask you what is the capital of Spain you might not be able to recall but if I ask you is Madrid the capital of Spain then you might recognize that you have read about this information before the same is true for user interfaces as well for example in the pre-gui era how could we move a file from one location to another in Linux so we had to type in a command such as MV the file name and the destination folder so users had to remember the command the parameters Etc but now moving a file from one location to another is pretty straightforward you just have to right click on the file or use shortcuts and you know how to do it another important aspect is that the interface the buttons navigation all of this should help the users reach their final goal an example of this is Google's recent change of their icons so here if you look at the image on top where the previous Google product icons were the color form and shape could help us easily determine the functionality of each app so for example the postcard like letter shape of the Gmail app is immediately recognizable and points to the functionality of Gmail that is checking and writing email however after the redesign all the apps have the same color and form the idea might have been to give a consistent design across Google products but a lot of people complained that they were finding it difficult to distinguish between different apps on small screens such as mobile phone hence it is essential that the user interface and buttons do not add the load of making users remember something"],
        5: ['https://youtu.be/EWEuCseFVEI',
        "in this video we will be looking at certain heuristics for feedback for providing appropriate feedback to users so the first heuristic is showing the status so this means that we need to keep users informed about what is happening through appropriate feedback and this feedback should be provided within a reasonable amount of time you have seen multiple instances of this in several applications so for example the loading status in browsers so it can be very frustrating if i have to stare at a blank screen while the page is loading so is the page actually loading is there an error so if i do not have a an animation which shows the loading status then it's very difficult for me to understand what the problem is another example is showing status of how much time a particular action will take so let's say if i'm downloading something how much time will it take to download so that is a useful information which can be given to users another example of showing status is to provide next steps to an action so for example if you have filled a form or if you have created a new email address so what are the next steps otherwise as a user i will not know what i should do next another example of showing status is to provide warnings in advance so it is important to let users know of some action which is needed from their side so for example if the gmail space is running out appropriate information on gmail can help me take appropriate steps such as buying storage the next heuristics are for preventing errors so why do users make errors so many times we often attribute errors which users make to something that the user did but it can also be the case that certain aspects of the user interface led users to make these errors so what are ways in which we can prevent users from making errors in the first place one example can be to include helpful constraints so for example this is an interface for booking a flight booking a flight from and the return journey as well and here you can see that the return date cannot be before the departure date so i have mentioned the departure date date as july 19th and the dates before july 19th have been grayed out so in this way the interface is constraining the user by not allowing them to fill a date before 19 july and hence we can prevent errors of of a user adding a date which is before the departure date another way in which we can prevent errors is to offer suggestions for example i may really not know what to do and the user interface can provide suggestions so that errors will be prevented later on so for example on the browser i type usability and i'm really not sure what i'm looking for but google auto suggest provides me a list of options as we see here and this is useful for me to choose the particular aspect of usability i am looking for now that we have seen how we can prevent errors the next heuristic is to support error recovery so how can we help users once they have made an error how can we support them to recover from these errors so one way to do it is to make the problem itself very clear so users might be interacting with your ui for the first time and it is essential that you specifically mention what the problem is so for example this is facebook signup form here a user has clicked on sign up without entering any of the details and here you see that each of these fields are highlighted in red and thus fa the interface makes the problem really clear for users and many times we should not only make the problem clear but we need to provide a solution as well so in the same interface you can see here that in this field the user had to enter an email a valid email or a mobile number and the tooltip here specifies the solution to this problem so it is important that our user interfaces provide appropriate solutions when users make errors another way to support error recovery is to provide an alternative to users there might not be an easy solution or the right solution but you can always offer different alternatives or different pathways for learners to reach their goal so for example here on in the google search i have typed in jacob nielsen and the spelling of nielsen is wrong and many a times you have seen google auto suggesting the correct search query so this is an example of how the user interface is providing an alternative for the learner and helps them support or helps them recover from their error the final heuristic is providing help to users so we need to ensure that help is easy to search and you must have seen that most tools have a menu item known as help which provides important help topics trainings updates etc another important aspect is to provide help in context write in time when and where the user needs it this is the interface of a learning management system known as moodle and in this case you can see that if i want to add a new course i can fill the details of the course and the course gets created however as a new user i may not know exactly what course visibility means so just next to each attribute like the course category the course visibility you have a help icon which will provide you details about that particular field this way help is provided in context exactly where and when the user needs it so in this and the previous videos we have seen several heuristics by which we can evaluate user interfaces so after the initial prototypes are ready you can allow experts to evaluate your interface so experts they do multiple passes through your prototype and produce a list of issues that violate some of these design heuristics so collecting feedback from several experts will help you fix multiple usability issues in your prototype and these heuristics are also kind of a self check for you and can enable you to design effective and usable software interfaces"],
        6: ['https://youtu.be/lq1kTWFG3Z0',
        "so in the previous weeks we looked at how we can gather requirements from users and design usable and effective interfaces so now that we have some idea on how to do this in the upcoming weeks we will look at how we can now start developing these systems that is the design and the development phase but one thing we have not touched upon till now is how will all this work get done so let's say there are different user stories different UI screens Etc we need a team to work on this development right and in most cases the success of software development often depends on how this team is managed and we need a person to manage such teams and usually the person who does this is a project manager a project manager is like the boss of a project and manages all aspects of the project but what does managing involve what does what all goes into managing a software project so let's reflect on this question what do you think are the responsibilities of a project manager so what all is involved in managing a project a software project you can pause this video and think about some answers before proceeding this project manager acts as the product owner serves as the point of interface between the customers or the stakeholders and the development team the project manager ensures that the customers requirements and needs are addressed looking from the development team's perspective the project manager is responsible for creating the team finding the right people putting them to do the right tasks but does her job end there she is also responsible for managing the team ensuring that people are staying on track and that the project moves forward towards a timely completion so what are some things involved now in managing a team let us consider a scenario for example the project is progressing well but at one point there is a technology decision to be taken there are multiple options available and one of them has to be chosen how does the project manager do this the project manager can consult the team members because they are familiar with what they are doing as well as the project manager consults experts outside the team in order to decide which technology feature to implement this way the project manager is responsible for taking the project forward to timely completion so when the team Works effectively the project moves forward but how do we know that it is moving forward so the project manager creates a plan or a schedule of how the development will continue and how the project will get completed so how do they do this So based on the requirements they divide these requirements into major activities which are required to complete the project they then break down each activity into tasks they check for dependencies between tasks and then create a plan we will learn about how we can schedule projects later this week now let's say I have broken each of these activities into tasks but now how do I know how much time is required for a particular task or a set of tasks so this is also another important activity that project managers handle that is estimating how much time is required for each task and activity in the project we will look at some of these estimation techniques this week as well so along with estimating the time required we also need to estimate other aspects like how big is the project the project size how much effort how many people are required to complete the project as well as the cost so cost estimation is also very important because the client needs to know how much they will be charged for developing the software project another aspect is to identify assess and mitigate risks in the project what could these risks be there could be various types of risks for example the some people from the team may leave so you need to have backup plans so project manager actually needs to anticipate such risks in a project as early as possible and as soon as a risk is identified there has to be an effective risk management and risk mitigation plan in place saying okay if that eventuality actually happens what are we going to do whatsoever plan a what's our plan B WhatsApp plan C so that the impact of the risk on the deliverables is minimized the project manager also has to account for how the final system will be configured that is which tools documentations Etc are required to combine all the modules so that the customer can use the system this is called configuration management in addition to this project managers also have to account for changes that can occur in the software system for example a developer may work on the system to create a new version of the code different versions of the system may also have to be managed while all this may sound abstract we will be going into detail of each of these ideas to summarize in software project management the key responsibilities of a software project manager are the manager is the main point of contact between clients and the development team the manager is responsible to form and manage the development team take care of scheduling estimation risk management configuration management and ensure that the product is delivered in a timely and within cost manner so all these responsibilities that we mentioned they are common practices and tasks in the plan and document perspective the goal has been to make software engineering predictable in budget and schedule foreign perspective so agile does not try to predict cost and schedule at the start of the project instead it relies on working with customers on frequent iterations and agreeing on a range of time for the best effort to achieve the customer's goals so for example in the agile perspective we take user stories and rate them in terms of their difficulty and we assign specific points to them we then record points completed per iteration so this gives us a more realistic estimate of the time and effort required so we will also look at agile software management techniques as well this week"],
    },
    4: { 
        1: ['https://youtu.be/MXz_9ds6PJM',
        "we looked at the practices involved in software project management right so what all are the important tasks that a software project manager does such as forming and managing the development team project scheduling project estimation risk management and so on so in this video we'll be talking about project estimation techniques so before we look at the actual techniques used for estimation let's reflect on why it is important to do project estimation so one is to establish the cost of the project right so I need to know how much money is required to build the software and this information has to be communicated to the clients second I also need to establish a schedule for the project right uh I need to know when the project is likely to get completed and as the project is moving along is it on schedule is it behind schedule how many people are required all these depend on the estimates of the project also from the client's perspective when they bid for software projects these cost and schedule estimates must be provided to the clients for the development contract and of course it is not possible to accurately establish or estimate the exact cost and the schedule and these estimates it depends on the level of information available about the project so the more detailed information we have about the project the more accurate the estimation can be so now let's reflect on this question on what all can be estimated in a project right so let's say you are running a company and you are bidding for software projects so what are the key parameters that you will provide an estimate for so what are the key parameters that are required to do project estimation you can pause this video and think about some parameters before proceeding so like let's look at some key estimation parameters right so some of you might have thought about the size of the code that is the number of lines of code yes this is important to estimate the number of lines of code and the number of lines of code is usually represented as K log which is number of thousand lines of code so one k lock is thousand lines of code so this is one estimation parameter but if you think about it the size of the code alone cannot be provided to the clients right so especially to justify the cost so another key estimation parameter is effort right and this is also an important parameter and based on this we can determine how many people are required to form the team right and in the software industry effort is usually measured in terms of person month so one person month is the effort an individual can typically put in a month so let's take an example uh let's say a project it requires 12 person months of development time right so we let's assume that we have estimated this quantity we will see how we can do this estimation but let's say we have got an estimate that this project requires 12 percent months of development time so what that means is if there are 12 people then this project and if all these 12 people work on this project for one month then this project can get completed right so if we have only four developers that means we this project will require three months and if we have just two developers then it will require six months so you might think it is better to think in terms of you know total hours how much hours does the entire project take but work is often expressed in person month units because it is easier to get a feel for how many people might be needed to finish the development work in a fixed time foreign so now that we have looked at some key estimation parameters let's look at project estimation techniques so one broad estimation technique is empirical estimation right and what this means is we ask experts we ask people who have completed similar projects in the past and they provide estimates for us for this new project another type of estimation technique is using heuristics right and what this means is relationships that exist between different parameters like we saw effort time these can be modeled using suitable mathematical expressions so we'll be looking at heuristic techniques also in this field cut so now let us look at some empirical estimation techniques right one popular empirical estimation technique is to use expert's judgment right so an expert he or she makes an educated guess about the problem size after analyzing the problem thoroughly right they estimate the cost of different components in the system and then they combine all these estimate for the individual modules to arrive at the overall estimate so now that we have seen what expert judgment is what do you think are drawbacks of this method what are the drawbacks of asking an expert to give the estimates for the project you can pause this video and think about some drawbacks before proceeding okay so now let's look at some drawbacks of expert judgment right so one is these experts are humans and hence they can make errors they can have some individual biases towards a particular technology or a particular framework and hence because of this they might give some optimistic estimates based on their expertise and also maybe if they want the contract to be won then they might give even more optimistic estimates another drawback is that they might Overlook some factors right they might not have adequate knowledge in particular areas so for example they might be very knowledgeable in the database and the user interface part but they might lack knowledge about maybe additional modules or additional plugins and because of this they cannot accurately provide an estimation so but do you think this can be solved by a group of experts so yes maybe to an extent but still the entire group can also be biased right and the decision made by the group it may be dominated by some members who are overly assertive or maybe some senior members so they might influence the decision of the entire group so to overcome the drawbacks of expert judgment the Delphi technique can be used so what is the Delphi technique so in this technique we have a group of experts and we have a coordinator so the coordinator provides each expert with a copy of the SRS the requirements and a form for recording the cost estimates so the experts go through the requirements the SRS the different modules and then they provide their estimates and they submit their estimates to the coordinator note that each of these experts are submitting it individually they are not discussing with each other and what the coordinator does is the coordinator prepares a summary and distributes it to all the estimators to The Experts now the experts look at this summary and based on this they re-estimate uh based on all the comments from all the experts and note that these comments are still Anonymous experts do not know who has provided the estimation and this process is iterated over several rounds and the coordinator compiles the results and prepares the final estimate so as we saw there's no no discussion between the experts is allowed during the entire estimation process because some experts or some people can get influenced by an experienced or a senior estimate and after several rounds of iteration the coordinator takes responsibility of compiling all the results and prepares the finalist foreign"],
        2: ['https://youtu.be/ziDmAaOrdkY',
        "we looked at ways in which we can estimate the time and effort required to execute a project so having these estimations in place another important part of project management is to create a schedule for the project so why is this creating the schedule important the schedule can help the project manager monitor the timely completion of each task and let's say if we are falling behind we can also take corrective action and this enables the entire team to move forward so now let's reflect on this question of how do you actually go about creating a schedule right so what are the main activities involved in Project scheduling can you think of some of these activities you can pause the video and think about some activities before proceeding okay so let's look at some of these activities right so one is we have to identify all the major activities which need to be carried out to complete the software project and once we have done that we have to break down each of these activities into smaller tasks and some of these tasks may be dependent on each another right so we have to determine the dependencies among these different tasks so for example task B can start only after task a has been completed or let's say task b c d can happen in parallel so such dependencies have to be determined and then we have to also estimate the time duration for each of these Stars and having this dependencies and time duration now we have to represent this information so that all members in the team will be aware of these dependencies and time durations and we'll be looking at some representations in this video then we go more concrete and start you know we think about the start dates the end dates for each of these tasks and then what we do is we determine the critical path so a critical path is a chain of tasks that determine the duration of the project so we'll be looking at what a critical path is and finally we allocate resources people or equipment or other things to these particular tasks so now let's look at how we can identify and break down each activity into tasks so one way to do it is to create what is known as a work breakdown structure or a WS what it does it it breaks down the project activities into a set of tasks and usually this is done by creating a tree like structure so the root will have the project name and each node is broken down into smaller activities which are the children of the node and then finally you come down to the leaf right and each Leaf it represents a task which can be allocated to a developer and which can be scheduled and each task takes roughly two weeks to develop of development time so let's look at a work breakdown structure for the Amazon Seller portal right so this is the name of the project which is the root and then you have different nodes uh for let's say requirement gathering for design for development and each of the leaf as we as we saw earlier it represents a task which can be allocated to a developer right and so for example some some people will start working on the component diagram others will start working on the database schema right and if we look at just the design and the development right so we can see that in the design you create the component diagram the database the user interface and the development involves all the modules or the requirements which we identified in previous videos so now that we know what these different tasks are now what we have to do is to create what is known as an activity Network which is nothing but now that we know what are the different tasks now we have to determine interdependencies how are these different tasks dependent on each other what are the estimated durations how much time will it take so all this can be done by creating what is known as an activity Network and the leaf nodes of the work breakdown structure which we saw earlier these becomes the nodes of the activity Network so let's look at one example the same example so this was the WBS or the work breakdown structure which we created now all of these Leaf nodes become part of the activity Network so this is one example and here you can see the arrows also determine the dependencies right so if you see the catalog management which is part of the development that can start only after you create the component diagram the user interface and the database schema right and so this graph like structure it determines the dependencies between different tasks and it also tells us how much day how much time or how many days are required for each task so here you can see that catalog management has to be completed before Inventory management management can start and order tracking can start only after Inventory management is completed but then we see that payment tracking sales tracking and customer feedback can happen in parallel right so this is one example of an activity Network so another way to represent this information is to create what is known as a Gantt chart so Gantt chart is a special type of bar chart and you can see that each bar it represents an activity or a task and the length of each bar is proportional to the time duration plan for that activity so in the case of the Amazon Seller portal we saw that the user interface and database schema can start together parallely right user interface takes longer than the database schema here we see that these three modules the catalog management Inventory management and tracking can happen only one after the other but once order tracking is done payment and sales and customer feedback all can happen in pair right so this representations provide the software manager as well as all the members of a team of the team A visual representation of how the project is scheduled and what are the different tasks which need to be done so to summarize in this video we looked at the main activities in scheduling first we need to identify all the major activities and break down of these activities into tasks which can be done by the work breakdown structure and then we saw the activity Network representation which can help us determine the dependencies and the time durations and representations like the Gantt chart can help us represent all of this information so that all members in the team will be aware of the schedule of the project now the next important type of project estimation techniques is known as heuristic techniques so in heuristic techniques we provide estimations by doing some modeling using some suitable mathematical expressions so a popular model which has been used to estimate effort is known as the constructive cost estimation model or the Kokomo model this model was proposed by bohem in 1981. and the formula which is used to estimate effort is effort is nothing but a multiplied by size raised to B where size is the size of the project in kilo lines of code and what are what is this A and B right so a the values of A and B it depends on the type of project or the type of software you are building so bohem he classified projects as one organic so an organic project involves building a very well understood application program and uh the size of the team is also small and all most of them are experienced another type of project can be a semi-detached project which has a mix of both experienced and inexperienced people and they might have some limited experience building related systems and the third type of project is an embedded project where it the project is strongly coupled with hardware and the team size also might be large and there might be many inexperienced people So based on the type of project there we assign different values for A and B and what you have seen is that the effort it not only depends on the size of the project but also the type of project the composition of the team is also an important factor in which the estimate depends on foreign empirical analysis of several projects Bowen came up with these values for a and b for each of the types of projects so you can see that the values of the constants of A and B they are based on the type of project right and for organic projects the values are the least it's 2.4 and 1.05 and it is highest for embedded projects and this makes sense because embedded projects as we saw it involves coupling with Hardware the team is large you know there might be many inexperienced people and because of this effort increases exponentially as the complexity of the project and the team increases So based on these constants the initial estimate or the nominal estimate is calculated in terms of the effort now let's take the example of the Amazon Seller portal and try to come up with the initial estimated effort to build such a system right the first thing which we need to identify is what type of system is this Amazon Seller portal right so according to me this is not a straightforward Software System there are several modules which have to interface with the main Amazon system with the banks for payment Etc so I would maybe classify it as a semi-detached system in some cases it can also be an embedded system right so now that we have identified what type of system it is now let us try to second thing to do is to estimate the number of lines of code so recall that we had identified some requirements in the previous weeks so we have adding editing deleting catalog the inventory tracking orders payments sales customer feedback so all of these things are there and for each of these modules I estimate the number of lines of code required so how how does one do it right so this itself is a very difficult task and usually the project manager looks at data from previous projects to come up with these estimates so for example in a previous project there would have been a module which captured customer feedback and based on that the software manager makes estimates for that module so I add up all the lines of codes for all the module and I get the total of 4000 lines of code which is nothing but four kilo lines of code so now let's look at uh the the estimations which we have till now we we know that the system is semi detached we have the size in kilo lines of code we plug these values in and we get the effort is roughly around 16 percent months or 15.83 percent person months so what does this mean this is our initial estimate right so we require around 15.83 percent months that is around 16 people working full time can finish this project in one month and based on this we can estimate the cost right so let's say that the average salary of the 16 people is 75 000 per month so then the total cost comes up to around 12 lakhs so now apart from the size of the code you know we need to consider other factors also to estimate the effort required for a project right so let's reflect on this so what are the other factors which have to be considered to estimate the effort required for a project you can pause this video and think about some other factors before proceeding okay so apart from the size of the project so what other factors have to be considered let's look at that so some of you might have said about the people working in the project right some team members maybe experienced but not in the programming framework required for this project others may not have domain experience so in this case in the case of the Amazon Seller portal you know how an e-commerce application works and hence some time we'll go in learning about the domain so another Factor can be the technical attributes or the finer details about the product so is the database large is it complex how complicated is the entire product so is reliability an important part of the system so these factors also have to be considered when we estimate the effort and estimation also depends on the tools and practices which are used by the team right uh how if the practices and tools are not very effective then maybe more effort is required for the project so in the Kokomo model after determining this initial estimate some other factors are added in order to obtain the final estimate and these factors are known as cost drivers right so this table shows 15 such cost drivers and these attributes like the product computer attributes personal attributes these are similar to what we discussed earlier right like software reliability so if the reliability required is very high then we we have a higher cost driver compared to when it is very low Okay so let's look at our example so let's say we want to estimate the effort for the Amazon Seller portal uh let's look at some of these attributes so for example we want the system to be highly reliable because orders and money are involved right so we will choose a cost driver which is very high for reliability and maybe my database size it is also quite large so I will choose uh a cost driver which is high now if we look at some Personnel attributes uh let's say my application experience of my team is low right so I will choose this as 1.13 Which is higher than when if it is very high and let's say my team has good programming language experience so I rate it as high right so multiplying so the multiplying factor for all 15 cost drivers they are multiplied to get the effort adjustment Factor right so in this case I'm just taking four drivers for Simplicity so let's recall that our initial estimate was 15.83 percent month now I take these cost drivers multiply all of them together and this gives me the effort adjustment Factor which is 1.62 and now my final estimate is calculated by multiplying the initial estimate with this effort adjustment Factor and so I get an estimate final estimate of 25.65 percent months so to summarize the Kokomo model first we determine the type of product which has to be built then we estimate the number of lines of code for each module and based on the formula we get the initial estimate and from this initial estimate we calculate the effort adjustment Factor by considering the 15 cost drivers and then we multiply the initial estimate with this adjustment factors to get the overall estimate so if you look have if you have noticed one important thing to note is that the overall estimate it depends on the estimation of the lines of code for each module right and so it is important to get as much detail about the software and we should also be aware of our biases when estimating the size of various components so to summarize in this video we looked at several estimation techniques both empirical and heuristic and another question now to ask is which technique to use right for a particular project so what estimation techniques project managers use it depends on various factors like the type of organization the type of product which which is being built right and it depends on the practices in your organization as well so for example uh the British computer Society survey of more than thousand projects found that 92 percent of the project managers they made their estimates using experience instead of formulas so now that we have learned these estimation techniques you will encounter these or maybe some variations of these as you start working in the software industry"],
        3: ['https://youtu.be/WvgqTJjp-0E',
        "in the previous video we looked at different ways in which we can create a schedule for our project so another aspect of project management is to identify and mitigate risks which can occur in a project so what is a risk so a risk is an anticipated unfavorable event that can occur while a project is underway so it is anticipated because based on previous experiences or particular characteristics of this project we can anticipate that such a risk can happen and it is unfavorable because these are things which can derail the project or maybe even cause the delays and even stop development of the entire project and in the case of software the intangible nature of software also makes it difficult to identify risks right because it is difficult to control something which we cannot see so let's take the example of building a house so we have a contractor or a construction manager who overlooks the entire construction right and he or she can see how the construction of the house is taking shape so for example setting the foundation you add slabs you add the frame the roofing interiors painting so in all these activities these are visible to the manager right he can see how the construction is taking place and can assess the progress of the work as well as control however in the case of software it is not often the case right for example a simple syntax error can break an entire system and also third-party modules which we use they can have certain vulnerabilities or it might be outdated and this can also delay the project so another thing to note is that software is built by people working in a team right and conflicts or disputes within the team can also cause delays or disrupt software development now that we have seen what risks are and why it's important to identify and mitigate risks let's reflect on what are potential risks in a system like the amazon seller portal so what do you think are potential risks or categories of risk in the amazon seller portal you can pause this video and think of some potential risks before proceeding so many of you would have thought about risks related to the technical aspects of the project and these risks are known as technical risk and these kind of risks occur due to the development team's insufficient knowledge about the product and it can occur at any stage in the software development process in the requirement phase the design the implementation testing or even the maintenance phase so what are examples of technical risk so one is the team develops the wrong functions or the user interfaces and this can occur mainly due to in ambiguous or incomplete requirements which we get from clients so how can we mitigate this risk so we have seen this earlier also we need to communicate with clients or we build prototypes and get feedback from them so that we do not develop the wrong functionality or interface another example of a technical risk is shortcomings in the external components right so external components are components which are built by a third party vendor and these might be buggy it might not be up to the mark it might have certain vulnerabilities so how can we mitigate this risk by benchmarking by periodic and regular inspections to see that the module is up to the mark now the next category of risks are project risk so project risks occur due to problems in the budget the schedule and personal resources or even customer related problems so all type of risks which are non-technical can be categorized as project risk so the most common risk is scheduled slippage right the project falls behind schedule and how can you mitigate this risk one is you create detailed milestones so we saw in the previous video about project scheduling and we create detailed milestones in the schedule itself so that the entire team is aware of the different milestones and we constantly iterate and we communicate frequently with the clients even if we are falling behind schedule another example of a project risk is insufficient domain knowledge or technical knowledge by members in the team so for example in the amazon seller portal maybe members of the team they would not have worked in an e-commerce application before so how do we mitigate this risk mainly by hiring right hiring the right kind of people with relevant experience maybe within the company who are working in different projects or outside the company and we can also outsource important modules to experienced third party vendors as well another type of project risk is personnel shortfall right people might leave the project or organization in between and how can we mitigate this risk this risk can be mitigated by cross training right we train multiple people with skills which are required to work on the project so for example in the amazon seller portal maybe we make multiple people work on the payment gateway module right as it requires specialized knowledge so it's good if multiple people work on that project now another category of risks are known as business risk right and these risks are risks which can harm the business aspects of the software product so for example by the time the product is complete maybe it is not competitive in the market right there might be other products which are doing much better so the way to mitigate this risk is to explore the market for similar products address the gaps which are there in these products right another example of a business risk is gold plating right we develop unnecessary features so the development team feels that there are some features which are very good which are very nice to have even though the clients have not expressed the need of such a feature right and this is known as gold plating and how can we mitigate this risk again we communicate with the clients to see if they really require this feature and also do a cost benefit analysis right is the feature important is it worth it does it add value does it satisfy the users needs and based on this we make a decision so to summarize we looked at several types of risks and how to mitigate them we looked at technical risks which are risk related to the technical aspects of the project then there are project risks which occur due to the non-technical aspects like budget scheduling and other factors and business risks are risks which can harm the business aspects of the software product now another important aspect is to assess which risks have to be worked on right so the project manager along with other team members they come up with a set of risks for the project so how do they do that so they ask everyone in the team for the worst case scenario and based on this the project manager creates what is known as a risk table and for each risk the project manager he or she assigns a probability p from 0 to 100 and what is the potential impact of this risk so if this occurs you know is it a negligible risk is it marginal is critical or is it catastrophic which can derail the entire project so what is the impact of that particular risk right and then the risk is calculated for each of the identified risk by multiplying the probability with its impact right and then you sort the table in descending order and then you decide which risk do you actually want to work on so let's take the example of the seller portal right so maybe as a project manager i decide that you know schedule slippage and lack of experience building e-commerce applications these are you know serious risks and their impact is also high and even personal leaving although the probability i decide as a manager is slightly lesser i the impact is quite high whereas another risk of you know the database not being able to scale for large numbers the impact of that is less and maybe the project manager believes that the team has sufficient technical expertise to mitigate this risk right so based on uh so the project manager identifies these risks and then assigns a probability and an impact to each of them and then sorts this table in descending order and then the team or the manager decides which which risks to actually work on so you cannot work or anticipate all the risks which can happen in the project but you focus on the most important ones and then the project manager can decide to mitigate these risks by maybe creating milestones by conducting regular meetings with the team and clients and to mitigate the lack of experience the manager will make sure that they hire the right people outside and within the company so in this way we saw how we can identify assess which risks are important and mitigate these risks as well"],
        4: ['https://youtu.be/nJ6JaNXWP2o',
        "videos of this week we looked at Key activities in managing a software project we looked at activities such as project planning estimation risk management and these are common practices and tasks in the plan and document perspective and if you recall in the plan and document perspective the goal has been to make software engineering predictable in budget and schedule so there is a lot of documentation and planning at the start of the project however if you look at it from the agile perspective agile does not try to predict cost and the schedule at the start of the project itself right instead it relies on working with customers on frequent iterations and then agreeing on a time and how much effort and cost is required now let's just recall the agile perspective and the philosophy which we discussed in the first week right so the agile life cycle is divided into iterations of typically one to two weeks and in each iteration certain user stories are implemented that is a working prototype is Created from these user stories and then users examine the work done in this iteration to see if it matches the requirements and then user stories are prioritized for the next iteration new user stories are created as well and then this process continues till the entire system is built so in this video we will be looking at how work is actually done from the agile perspective or how is planning done how is scheduling done and what all happens for this work to get done so let's look at how teams are formed right so as we saw in the plan and document perspective one of the first jobs of the project manager is to form and organize a team so in the agile perspective the team size is roughly four to nine people for a particular project of course this varies from company to company and now the question is if you have Steve now how do you organize development in this team right and there are various strategies and Frameworks and we will be looking at one of them in this video which is known as scrum and let's see what scrum looks like so at the heart of scrum is a Sprint right a Sprint is short time box period when a scrum Team Works to complete a set amount of work right so there is a team which works in what is known as different Sprints or iterations and with scrum this product is built in a series of iterations which are known as sprints and in the in these prints the complex project is broken down into small pieces now let's look at the main roles in a scrum team so there are three main roles in a scrum team one is the development team so the people who do the actual work of developing the software and many of you might think of only coders or developers in the development team right but this is not so so whoever is required to complete the work in that given Sprint they can form a part of the they are they form the part of the development team so it can be designers developers testers who form a part of a development team now the second role is that of a product owner right a product owner is a person who interfaces between the client and the development team and the product owner ensures that the team is delivering the most value to the client and the product owner also takes into account other stakeholders in the organization for example the constraints of developers technology constraints Etc and communicates all of this to the client so the most important responsibility of the product owner is to take all these inputs from the clients and the development team and prioritize the work to be done in a particular Sprint foreign and the third role is known as a scrum master the scrum Master ensures that all the activities in the scrum are being done well right he or she helps the product owner Define value and the development team to deliver the value to the product the scrum Master also serves the organization at large helping the organization understand what scrum is and create an environment that supports scrum foreign activities in scrum so before you start a Sprint view conduct a meeting known as a Sprint planning meeting so this is a collaborative event between the product owner the scrum master and the development team right and the team asks two basic questions about what work can get done in this print and how will the chosen work get done right so the team chooses a subset of all the tasks which are required to be done and decides on which tasks have to be done in this spread and the Sprint planning activity or meeting is time boxed and it is roughly two hours per week of the iteration so then how do we know what all are the tasks which are required to be done in a particular Sprint or what is the entire set of tasks for developing that product so that is where the product backlog comes in right so product backlog is a prioritized list of work for the development team and this is derived from the user stories and the requirements so the most important items are shown at the top of the product backlog so that the team knows what has to be delivered first so now who prioritizes these items in the product backlog so it is not the product owner but in the Sprint planning meeting all the team members collectively come up with the items which will be worked on in in this print in a particular Sprint so for example the product owner may say you know the client requires these user stories immediately but the development team may State their constraints and then the entire team would come to a consensus now let's look at an example of a product backlog let's take the example of the Amazon Seller portal itself right and in previous weeks we have come up with some user stories based on the requirements and this involved you know managing the catalog managing the inventory tracking the orders payments sales Etc and now we have to decide for a particular Sprint what are the items we need to work on so let's say for the first print the developers say okay we can work on catalog management maybe we can work on one a and one B of adding and editing catalog items but then the product owner tells well actually the client wants to see catalog management as well as inventory management so then the developers might say that you know it's not possible to complete both in this print maybe we can focus on adding a catalog item and maybe adding an item in the inventory so we can focus on one a and two a so the entire team concern comes to a consensus and decides to work on one a and 2A in this Sprint so this image is taken from a popular software management software which is known as jira so in jeera I can create a backlog which has all these issues or these are known as the items in the backlog and this is similar to what we saw in the previous screen and then for a particular Sprint I can create Sprints and I can take items from the backlog and add it to the Sprint and then I can decide a timeline for the Sprint I can assign specific user stories to specific people and all this can be done in most software project management tools and by the end of the Sprint planning meeting now the team has decided which are the issues which will be worked on in this particular Sprint and now the team is ready to start work on the Sprint backlog taking items from the backlog to the in progress and the done tabs so here you can see that there are three boards and as we saw in the previous screen we have decided to work on two items and these two items are present in the to-do list for this print for Sprint one so now that we have seen what happens in a Sprint planning meeting and we know what are the items to be worked on for a particular Sprint now how does the team make progress for in this particular Sprint right and this is done using a stand-up or a daily scrum meeting so this meeting is a daily meeting which involves the development team the scrum owners from master and the product manager and basically each member of the team answers three key questions one is what did I work on yesterday what am I working on today and what issues am I facing or what issues are blocking my progress right and when each member answers these questions it strengthens the team because everyone shares the progress of how they are contributing to the team so this daily scrum meetings continue till the end of the Sprint and hopefully by the end of the Sprint the team would have developed a prototype or the features for that particular Sprint and this progress is reviewed in the Sprint review meeting right so after that Sprint the team demonstrates what they have completed during the Sprint review meeting so what all things were there in the to do or the in progress buckets they would have ideally been moved to the done bucket and the team demonstrates what they have completed in that spread and finally there is a Sprint retrospective meeting and there this serves several purposes so one is to evaluate the last Sprint in terms of the Team Dynamics how did the team work the processes the tools so it is basically an evaluation of how things went in the previous print and also discuss and talk about which user stories or tasks went well or didn't go well do well so what are the reasons behind that and finally creating and implementing a plan to improve how the team does work right so that it will improve in the upcoming sprints so to summarize we looked at a framework known as scrum in this video right and scrum has several activities the key being the Sprint which is a short one to two week duration in which certain items are decided on and the team works on completing those items we looked at the scrum team we looked at several meetings or several activities in the scrum which is the Sprint planning the daily scrum meetings and the Sprint review and the Sprint retrospective meetings which are conducted after this print ends now let's look at how we can do project scheduling in agile so if you recall in the plan and document perspective we looked at project scheduling techniques like breaking down the activity into tasks and creating representations like a Gantt chart so in the agile methodology we do it slightly differently as we saw in this video work is done in Sprints or iterations of typically one to two weeks and in each iteration certain user stories are implemented so the key indicator of progress is how many user stories have been delivered to the client in each iteration so we can do project estimation by simply counting the number of user stories completed per iteration and then calculate the average number of stories per week and this will give us an estimate of how much time effort and cost is required to complete the entire project so let's take the example of the seller portal so we previously identified that we require or we can complete two user stories in Sprint one and we have a total of 8 plus to 10 user stories so we can complete the entire set of 10 user stories in five iterations which is nothing but and let's say each iteration takes two weeks so in 10 weeks we can complete the entire project so this helps us Define the schedule for the project so now let's just reflect on this process which we did so what we are saying is that by counting the number of user stories completed per Sprint we can estimate the time required to complete the project so do you think this is a good idea so what can go wrong if we follow this approach for estimation you can pause this video and think about some issues related to this approach and then proceed the key issue is that not all user stories require the same effort right some are much harder to implement than others and this can lead to mispredictions so one solution can be to rate each user's story on a scale right so we say the rating for a user story is one if it's a very straightforward and a simple user story two if it is of medium difficulty or effort and three if it is a very complex user story so now we have assigned points to each user story and now we can calculate what is known as a velocity which is nothing but the number of points per iteration or Sprint right and this term velocity in a way it measures the work rate of the team right in one iteration how many points is the team able to complete and this helps stakeholders also to get an idea of how many iterations it will take a team to add the desired set of features for example in the seller portal the team assigns points to each user story so here we can see that ad catalog is assigned two points add inventory item is also assigned two points and some other user stories are assigned one point and now the team decides to work on these two user stories in Sprint one and let's say after this print they have successfully completed these two items so we see that the velocity of this team is 4 2 plus 2 so in a Sprint this team is able to complete user stories totaling four points right so now in the next iteration instead of just working on two user stories the team can very well work on all four because it requires Four Points to complete and we know that the team can complete four points in a single iteration so in this way project scheduling for an Agile development process can be done using points and velocity so now we just compare the project scheduling in the plan and document and the agile perspectives so in the plan and document perspective it is done early in the project right at the start where we break down the project into tasks and then we create Gantt charts and Milestones which Define the schedule of the project whereas what we saw in the agile perspective is that we create user stories and we assign points to these user stories and we calculate velocity to and this where this term velocity helps us schedule the iterations and Sprints and how much time the project will take to get complete"],
        5: ['https://youtu.be/54t-QUr9h18',
        "tool known as pivotal tracker so pivotal tracker encompasses several of the ideas regarding agile which we discussed this week so basically what pivotal tracker does is it tracks user stories and velocity so let's look at some of the functionalities of pivotal tracker so you can go to this URL pivotaltracker.com and you can sign up as a new user and after you sign up you will most likely get a tutorial video which I encourage all of you to watch and it gives up an overview of what all prevented tracker does so after you log in you have to give or you have to name your first project so let's say we name it as iits software engineered in Project right and when I click on create project you see several Windows several tabs right so the first thing which you see is known as a current iteration or the backlog so this is similar to the product backlog idea which we saw this week right so this describes user stories that you're currently working on or stories which are prioritized to work on in a particular in the current iteration right and icebox is just like a dumping place where you can add ideas or stories which haven't been prioritized yet right and here you can see that this is the length of the iteration so let's say I choose my iteration of Sprint to be two weeks and so it gives the dates 18 to 21st August and I can also add members to my team so for example right now I am the only one but you can invite people to join this project and they become part of the team so let's now try adding some user stories so let's take the example of the Amazon Seller portal itself and if you recall we had several user stories so let's say I add one story in which I add a catalog item right and the story type there are several story types but right now we are just focusing on features or new features which we want to add priority let's say it's of a high priority and you can assign points to it so let's say I assign two points to it which tells me that it's a medium sized user story it's not too difficult it's not too easy right I can add some description some labels so if I have links to a code to a branch in GitHub I can add that here and I can also add tasks to this user story so let's say if I want to add a catalog item if that is the main user story then maybe I can add a task saying create and review UI screen or maybe create the DB table for catalog right so these are just some example tasks right then I can add comments or yeah and I can also assign or create owners for this right so I click on Save right and so now I have created a user story and this is there in my current iteration right so similarly I can add another user story of say let's say if I want to add an inventory item and this is also a feature this is also let's say of high priority and this also requires say two points right so here then I can add several user stories now another important feature of Pi pivotal tracker is epics right so so what are epics so epics are you know a collection of related user stories we can group several user stories into what is known as an epic so for example catalog management right can be considered as an epic right because we have several user stories like adding a catalog item editing you know viewing all of them deleting a catalog item all of them all these users stories are part of this Broad idea known as Epic so then I can add some description and I can add a comment or something I'm leaving everything blank right so catalog management is an epic similarly Inventory management can be considered another epic right and so now that we have added documentary and a big a user story known as ADD inventory item now we can assign this to the catalog man sorry the inventory management Epic right and similarly for the add catalog item you can link it to the catalog management thank you mate and as we said ice box are ideas or stories that have not been prioritized yet so for example customer feedback can be an idea which we want to implement in the future let's say order tracking is another one right okay so now that we have some user stories and epics now uh we can and we can also determine the velocity for example in this iteration how many points can I complete and that is known as the velocity so let's say uh I choose my velocity to be 4. right and now I can assign these user stories to different users or different people in my team and right now I'm the only one so let's say I start working on this on the add catalog item user story so I click on start right and then I start working on it and then maybe I add some comments let's say I added the UI screen please review right maybe I can add an attachment a file upload or a link right so it gives me a trace of what all I have done right and let's say I have created the UI screen I've created the database table I've finished the tasks in this right then what I can do is I can say that it's finished and once I've finished a user story then I can click on deliver and what does this does is this sends a status update to the product owner and the product owner can look at this user story and look at the comments or look at the links provided can review it and choose to either accept or reject this user story so let's say I find certain shortcomings and or some bugs and I I as a product owner I reject it and I say let's say too many bugs many s cases are failing please fix right something like that so it now it goes back to the person who was do who was in charge of this user story right so then I can choose to restart it and continue doing that the same thing for the ad inventory item right I can for this user story I can similarly you know add multiple tasks post comments send or post links to the completed event to the completed user story and then I click on finish and then I click on deliver and now this goes to the product tool now the product owner can choose to accept it right and this shows that now in my current iteration or backlog this user story is completed and this is ongoing right and if you look at let's say done right so so this is this is an overview of what all can be done in this tool known as the pivotal tracker and there are other features like analytics for example now it shows project Trends right uh what is the rejection rate how many stories have been accepted what is the story cycle time right what are recent epics so these are different statistics which the product owner or members of the team can see and this is these are useful metrics which will help the team move forward and improve in subsequent iterations so this is a basic overview of this tool known as pivotal tracker and you can use this or similar Tools in your own software projects as well and this gives you a a clear picture of the entire software project what are the different user stories what is going on right now and it can help members of the team to sync up together and move the project forward"],
        6: ['https://youtu.be/3Yje9oOOaFc',
        "in the previous weeks we started with requirements we created an SRS we looked at user stories we created the UI for these stories now before we start development we have to create the design of the system what is the design design is a way of organizing the core that you will implement and providing a structure to the software system how do we go about doing this and what should we get after such a design process is it the code directly or is it some intermediate representation what is the outcome of this design process we will look at all these points in this week so what is the outcome of the design process broadly speaking there are four outcomes firstly we have the components of the different aspects of the design then there are the interfaces between the components then we have the data structures which store the data and we have the algorithms which run on this data in order to produce the desired result so what are each of these [Music] so the components are what you might understand as modules of the solution so it is a collection of functions and data shared by these functions so the idea behind these modules is that each module should accomplish some well-defined task and the modules all work together to provide the functionality of the system what are interfaces interfaces are nothing but the way in which components or modules communicate with each other so they Define the manner in which data is exchanged between these components the need here is that the sending component and the receiving component need to be able to understand how to interpret the data that is exchanged so that is called an interface we will learn more about this as we go along then there are the data structures for individual components right I mean you are all familiar with arrays and lists and trees and so on so how different data is implemented or stored is captured by the data structures that we use within the modules and finally there is the algorithm which actually runs which on the data in order to produce the desired effect so components and interfaces are the key elements in a high level software design this high level design is known as the software architecture once the architecture is decided then we can move into lower level design details as we will see in the coming videos the focus of this week is to understand how we can represent this high level design of the system in later weeks we will look at essential practices and guidelines for creating effective software architectures there are many different types of notations that are used to represent a high level design the most popular one is called uml or unified modeling language uml can be used to describe different views of the system a user's view a functionality view a messages View and so on so we will look at uml diagrams in detail in the upcoming videos so now let's look at the example of the Amazon Seller portal right we have looked at this example in the past weeks as well so how did we start building this system so we started with the requirements which we collected from the clients from the stakeholders through the SRS through user stories and we created different user stories which describe different functionalities of this system for example we have a view inventory user story which enables a seller to view his or her inventory and we have another feature for tracking customer feedback so we collected several or created several of these user stories and now we have to implement and now that we have these different requirements or user stories now we identify common functionalities and we then group them together into tasks we saw this in the software project management week right and these tasks can form the components of the system for example we identified components like the catalog management component the inventory management payment tracking and so on so now how can these broad or these components be represented using uml diagrams and other notations is the focus of this week so here is a reflection spot what is good software design let us say you come up with the main components and interfaces of your system now how do you know that this system is good take a moment to think about this there are many characteristics of a good software design one of them is called correctness that is does it correctly implement the functionality of the system as we saw earlier the main way to do this is to ensure that requirements are correctly captured first ensure that the requirements are not ambiguous they do not conflict with each other and they are complete this can ensure that all the functionalities are correctly captured in the design another characteristic of good software design is efficiency efficiency means that we want to ensure that the resources that is the time and the space and the cost are managed well for example when you are trying to choose the development framework for an application you have to decide whether this is the correct one that depends upon the application whether you are building a client server application or whether you are building a mission critical system and so on for example if you are building an embedded system then it has to work under limited memory sizes so does the design ensure that these considerations are met so this is another important Criterion that characterizes good software design one more important characteristic is maintainability that is indain the code or in the code or make some changes as we saw earlier requirements can change either during the process of software design itself or later so new requests can come even after the product is released sometimes you want to upgrade the product let us say so in all these cases we do not want to redesign the entire software from scratch so it is important to ensure that the design is maintainable what does that mean that means that we can make these changes in the existing design and the existing code itself without too much effort and finally one more important characteristic of good software design is understandability what do we mean by understandability and why is it important understandability simply means that everyone in the team should be able to follow the design why is it important unless everybody can understand the design they won't be able to implement the system which can in turn lead to bugs and higher development as well as maintenance costs so apart from correctness understandability is also an important issue to consider while judging a design in this week we will look at certain characteristics which make the design more understandable hence in turn leading to creation of better designs"]
    },        
}










